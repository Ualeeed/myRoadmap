---
DONE: true
DATE: 2025-08-21T00:34:00
---




## What are Enums?

An enumeration is a distinct type whose value is restricted to a range of values, which may include several explicitly named constants ("enumerators"). Enum is a collection of named integer constants means it's each element is assigned by an integer value.

Enums are **User-defined data types** that allow you to define a set of named constants, making your code more readable, maintainable, and less prone to errors.

## Traditional Enums (C++98 Style)

### Basic Syntax

```cpp
#include <iostream>
using namespace std;

enum Color {Red, Green, Yellow, Blue};

int main() {
    Color MyColor;
    MyColor = Color::Yellow;  // or simply MyColor = Yellow;
    
    cout << "Color is: " << MyColor << endl;  // Outputs: 2
    return 0;
}
```

### Default Values and Custom Assignment

**Note**: C++ by default starts counting enums like that: {0, 1, 2, 3, 4...}
- Red = 0, Green = 1, Yellow = 2, Blue = 3

You can modify enum values as you want:

```cpp
#include <iostream>
using namespace std;

enum Color { Red=100, Green=20, Yellow=5, Blue=29};
enum Directions {North, South, East, West};
enum Week {Mon=1, Tue, Wed, Thu, Fri, Sat, Sun}; // Tue=2, Wed=3, etc.
enum Gender { Male, Female};
enum Status { Single, Married};

int main() {
    Color MyColor;
    Directions MyDirection;
    Week Today;
    Gender MyGender;
    Status MyStatus;

    MyColor = Color::Blue;        // Blue = 29
    MyDirection = Directions::North; // North = 0
    Today = Week::Thu;            // Thu = 4
    MyGender = Gender::Male;      // Male = 0
    MyStatus = Status::Married;   // Married = 1

    cout << "MyColor is: " << MyColor << endl;  // Outputs: 29
    cout << "Today is: " << Today << endl;      // Outputs: 4
    
    return 0;
}
```

### Problems with Traditional Enums

Although unscoped enumerations are distinct types in C++, they are not type safe, and in some cases will allow you to do things that don't make sense.

```cpp
#include <iostream>
using namespace std;

enum Color { red, blue };
enum Fruit { banana, apple };

int main() {
    Color color = red;
    Fruit fruit = banana;
    
    // Problem 1: Implicit conversion to int
    int x = color;  // This compiles! x = 0
    
    // Problem 2: Comparison between different enum types
    if (color == fruit) { // This compiles and returns true!
        cout << "color and fruit are equal" << endl;
    }
    
    // Problem 3: Name pollution in global scope
    // red and banana are in global scope
    
    return 0;
}
```

## Scoped Enums (enum class) - C++11 and Later

C++11 has introduced enum classes (also called scoped enumerations), that makes enumerations both strongly typed and strongly scoped. Class enum doesn't allow implicit conversion to int, and also doesn't compare enumerators from different enumerations.

### Basic enum class Syntax

```cpp
#include <iostream>
using namespace std;

enum class Color { Red, Green, Yellow, Blue };
enum class Status { Active, Inactive, Pending };

int main() {
    Color myColor = Color::Red;
    Status userStatus = Status::Active;
    
    // This won't compile - no implicit conversion to int
    // int x = myColor;  // ERROR!
    
    // This won't compile - different enum types
    // if (myColor == userStatus) { }  // ERROR!
    
    // Correct way to get integer value
    int colorValue = static_cast<int>(myColor);
    cout << "Color value: " << colorValue << endl;  // Outputs: 0
    
    return 0;
}
```

### Specifying Underlying Types

Since C++11, you can specify the underlying type of enumeration and save memory.

```cpp
#include <iostream>
using namespace std;

// Different underlying types
enum class SmallEnum : char { A, B, C };           // Uses 1 byte
enum class MediumEnum : short { X=1000, Y, Z };    // Uses 2 bytes  
enum class LargeEnum : long long { Big=1000000000LL }; // Uses 8 bytes

// Traditional enum - compiler chooses minimal type
enum TraditionalEnum { Val1, Val2, Val3 };         // Usually int (4 bytes)

int main() {
    cout << "Size of SmallEnum: " << sizeof(SmallEnum) << " bytes" << endl;   // 1
    cout << "Size of MediumEnum: " << sizeof(MediumEnum) << " bytes" << endl; // 2
    cout << "Size of LargeEnum: " << sizeof(LargeEnum) << " bytes" << endl;   // 8
    cout << "Size of TraditionalEnum: " << sizeof(TraditionalEnum) << " bytes" << endl; // 4
    
    return 0;
}
```

## Advanced enum class Features

### Forward Declaration (C++11)

```cpp
// Forward declaration of enum class
enum class Color : int;  // Must specify underlying type

// Later definition
enum class Color : int { Red, Green, Blue };

void processColor(Color c);  // Can declare functions before full definition
```

### Using enum class with Switch Statements

```cpp
#include <iostream>
using namespace std;

enum class TrafficLight { Red, Yellow, Green };

string getLightAction(TrafficLight light) {
    switch (light) {
        case TrafficLight::Red:
            return "Stop";
        case TrafficLight::Yellow:
            return "Caution";
        case TrafficLight::Green:
            return "Go";
    }
    return "Unknown";  // Should never reach here
}

int main() {
    TrafficLight currentLight = TrafficLight::Red;
    cout << "Action: " << getLightAction(currentLight) << endl;
    return 0;
}
```

## Memory Optimization and Performance

However an enum class's underlying type defaults to int while regular enum the type is unspecified and the implementation is free to select a minimal integral type.

### Choosing the Right Underlying Type

```cpp
#include <iostream>
using namespace std;

// Choose based on value ranges
enum class Priority : unsigned char { 
    Low = 1, Medium = 2, High = 3, Critical = 4 
};  // Only need 4 values, char is sufficient

enum class ErrorCode : int { 
    Success = 0, 
    FileNotFound = 404, 
    ServerError = 500,
    DatabaseError = 1001 
};  // Larger values need int

enum class LargeValues : long long {
    SmallValue = 1,
    HugeValue = 0x1FFFFFFFFLL
};  // Very large values need long long

int main() {
    cout << "Priority size: " << sizeof(Priority) << " bytes" << endl;      // 1
    cout << "ErrorCode size: " << sizeof(ErrorCode) << " bytes" << endl;    // 4  
    cout << "LargeValues size: " << sizeof(LargeValues) << " bytes" << endl; // 8
    return 0;
}
```

## Modern C++ Features (C++17, C++20, C++23)

### C++17: using enum Declaration

```cpp
#include <iostream>
using namespace std;

enum class Color { Red, Green, Blue };

int main() {
    using enum Color;  // C++17 feature
    
    // Now we can use enum values without qualification
    Color c1 = Red;    // Instead of Color::Red
    Color c2 = Green;  // Instead of Color::Green
    
    cout << "Colors: " << static_cast<int>(c1) << ", " << static_cast<int>(c2) << endl;
    return 0;
}
```

### C++20: using enum in Switch

```cpp
#include <iostream>
#include <string>
using namespace std;

enum class Status { Pending, Approved, Rejected };

string getStatusMessage(Status s) {
    switch (s) {
        using enum Status;  // C++20 feature
        case Pending:   return "Waiting for review";
        case Approved:  return "Request approved";
        case Rejected:  return "Request rejected";
    }
    return "Unknown status";
}
```

### C++23: std::to_underlying

A better choice in C++23 is to use std::to_underlying() (defined in the < utility > header), which converts an enumerator to a value of the underlying type of the enumeration.

```cpp
#include <iostream>
#include <utility>  // C++23
using namespace std;

enum class Level : short { Beginner = 1, Intermediate = 5, Advanced = 10 };

int main() {
    Level currentLevel = Level::Intermediate;
    
    // C++23 way (preferred)
    auto value = std::to_underlying(currentLevel);  // Returns short
    
    // Pre-C++23 way
    auto oldValue = static_cast<short>(currentLevel);
    
    cout << "Level value (C++23): " << value << endl;      // 5
    cout << "Level value (old): " << oldValue << endl;     // 5
    
    return 0;
}
```

## Best Practices and Guidelines

### 1. Prefer enum class over traditional enum

Why is enum class considered safer to use than plain enum? - Type safety and scoping.

```cpp
// Preferred ✅
enum class NetworkState { Disconnected, Connecting, Connected };

// Avoid ❌  
enum NetworkState { Disconnected, Connecting, Connected };
```

### 2. Choose appropriate underlying types

Since C++11, you can specify the underlying type of enumeration and save memory.

```cpp
// Good - memory efficient ✅
enum class ButtonState : unsigned char { Released, Pressed };

// Wasteful for simple enums ❌
enum class ButtonState : long long { Released, Pressed };
```

### 3. Use meaningful names

```cpp
// Good ✅
enum class DatabaseResult { Success, ConnectionFailed, QueryError, Timeout };

// Poor ❌  
enum class DbRes { OK, ERR1, ERR2, ERR3 };
```

### 4. Don't mix enums with unrelated values

In this case, you should use a constexpr value.

```cpp
// Bad ❌
enum { red = 0xFF0000, scale = 4, is_signed = 1 };

// Good ✅
constexpr int red = 0xFF0000;
constexpr short scale = 4;
constexpr bool is_signed = true;
```

## Practical Examples

### Example 1: Game State Management

```cpp
#include <iostream>
#include <string>
using namespace std;

enum class GameState : unsigned char {
    Menu,
    Playing, 
    Paused,
    GameOver,
    Victory
};

enum class PlayerAction {
    MoveUp,
    MoveDown,
     
    MoveLeft,
    MoveRight,
    Attack,
    Defend,
    UseItem
};

class Game {
private:
    GameState currentState;
    
public:
    Game() : currentState(GameState::Menu) {}
    
    void processAction(PlayerAction action) {
        if (currentState != GameState::Playing) {
            cout << "Action ignored - game not in playing state" << endl;
            return;
        }
        
        switch (action) {
            using enum PlayerAction;
            case MoveUp:    cout << "Moving up" << endl; break;
            case MoveDown:  cout << "Moving down" << endl; break;
            case Attack:    cout << "Attacking!" << endl; break;
            // ... other actions
            default: break;
        }
    }
    
    void changeState(GameState newState) {
        currentState = newState;
        cout << "Game state changed to: " << static_cast<int>(newState) << endl;
    }
};
```

### Example 2: HTTP Status Codes

```cpp
#include <iostream>
#include <string>
using namespace std;

enum class HttpStatus : int {
    OK = 200,
    Created = 201,
    BadRequest = 400,
    Unauthorized = 401,
    Forbidden = 403,
    NotFound = 404,
    InternalServerError = 500
};

class HttpResponse {
private:
    HttpStatus status;
    string message;
    
public:
    HttpResponse(HttpStatus s, const string& msg) : status(s), message(msg) {}
    
    string getStatusMessage() const {
        switch (status) {
            using enum HttpStatus;
            case OK: return "Success";
            case Created: return "Resource created";
            case BadRequest: return "Invalid request";
            case Unauthorized: return "Authentication required";
            case Forbidden: return "Access denied";
            case NotFound: return "Resource not found";
            case InternalServerError: return "Server error";
        }
        return "Unknown status";
    }
    
    int getStatusCode() const {
        return std::to_underlying(status);  // C++23
        // return static_cast<int>(status);  // Pre-C++23
    }
};
```

## Summary

Enums in C++ provide a powerful way to define sets of named constants. Modern C++ (C++11 and later) introduces `enum class` which offers:

1. **Type Safety**: No implicit conversions or invalid comparisons
2. **Scoping**: Names don't pollute the global namespace  
3. **Memory Control**: Specify underlying types for optimization
4. **Future-Proof**: Support for modern C++ features

Always prefer `enum class` over traditional `enum` in modern C++ code for better safety and maintainability.
