---
DONE: true
DATE: 2025-08-21T01:01:00
---


#### **The continue statement** 
is used to skip the current iteration of the loop. It causes the remaining portion of the enclosing for, range-for, while or do-while loop body to be skipped and is used when it is otherwise awkward to ignore the remaining portion of the loop using conditional statements.

## Key Behavior
With the continue statement we can stop the current iteration of the loop, and continue with the next. When C++ hits continue, it skips (not execute) any code left, and jumps directly to the next iteration instead.

---

## How Continue Works in Different Loops

### For Loop
In a for loop, `continue` skips to the increment/update statement, then checks the condition.

```cpp
for(initialization; condition; update) {
    // code before continue
    if(condition_to_skip) {
        continue; // jumps to update statement
    }
    // code after continue (will be skipped)
}
```

**Example:**
```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Numbers from 1 to 5, skipping 3:" << endl;
    
    for(int i = 1; i <= 5; i++) {
        if(i == 3) {
            continue; // Skip when i equals 3
        }
        cout << i << " ";
    }
    cout << endl;
    
    return 0;
}

// Output: Numbers from 1 to 5, skipping 3:
//         1 2 4 5
```

### While Loop
In a while loop, `continue` jumps back to the condition check.

```cpp
while (condition) {
    // code before continue
    if(condition_to_skip) {
        continue; // jumps back to condition check
    }
    // code after continue (will be skipped)
}
```

**Example (Fixed):**
```cpp
#include <iostream>
using namespace std;

int main() {
    int i = 1;
    
    cout << "Even numbers from 1 to 10:" << endl;
    
    while(i <= 10) {
        if(i % 2 != 0) { // Skip odd numbers
            i++; // Important: increment before continue!
            continue;
        }
        cout << i << " ";
        i++;
    }
    cout << endl;
    
    return 0;
}

// Output: Even numbers from 1 to 10:
//         2 4 6 8 10
```

### Do-While Loop
The continue statement works in the same way for the do...while loops.

```cpp
do {
    // code before continue
    if(condition_to_skip) {
        continue; // jumps to condition check
    }
    // code after continue (will be skipped)
} while(condition);
```

**Example:**
```cpp
#include <iostream>
using namespace std;

int main() {
    int i = 1;
    
    do {
        if(i == 5) {
            i++;
            continue; // Skip printing 5
        }
        cout << i << " ";
        i++;
    } while(i <= 7);
    
    cout << endl;
    return 0;
}

// Output: 1 2 3 4 6 7
```

---

## Continue with Nested Loops

When continue is used with nested loops, it skips the current iteration of the inner loop. The most readable way to solve this classic problem is almost always to put the nested loops in a function.

**Important**: Continue only affects the immediate enclosing loop, not outer loops.

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Matrix with skipped elements:" << endl;
    
    for(int i = 1; i <= 3; i++) {
        cout << "Row " << i << ": ";
        
        for(int j = 1; j <= 5; j++) {
            if(j == 3) {
                continue; // Only skips inner loop iteration
            }
            cout << j << " ";
        }
        cout << endl;
    }
    
    return 0;
}

// Output: Matrix with skipped elements:
//         Row 1: 1 2 4 5
//         Row 2: 1 2 4 5  
//         Row 3: 1 2 4 5
```

### Handling Nested Loop Continue Issues
When you need to continue an outer loop from an inner loop, consider these approaches:

#### Method 1: Using a Flag Variable
```cpp
bool skipOuter = false;

for(int i = 0; i < 5; i++) {
    for(int j = 0; j < 5; j++) {
        if(someCondition) {
            skipOuter = true;
            break; // Break inner loop
        }
        // inner loop code
    }
    
    if(skipOuter) {
        skipOuter = false;
        continue; // Continue outer loop
    }
    
    // outer loop code
}
```

#### Method 2: Extract to Function (Recommended)
```cpp
void processRow(int row) {
    for(int j = 0; j < 5; j++) {
        if(someCondition) {
            return; // Return from function = continue outer loop
        }
        // process column
    }
    // process rest of row
}

int main() {
    for(int i = 0; i < 5; i++) {
        processRow(i);
    }
    return 0;
}
```

---

## Common Use Cases

### 1. Input Validation
```cpp
#include <iostream>
#include <limits>
using namespace std;

int main() {
    int number;
    
    while(true) {
        cout << "Enter a positive number (0 to quit): ";
        
        if(!(cin >> number)) {
            cout << "Invalid input! Please enter a number." << endl;
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            continue; // Skip to next iteration
        }
        
        if(number == 0) break;
        
        if(number < 0) {
            cout << "Please enter a positive number!" << endl;
            continue; // Skip to next iteration
        }
        
        cout << "You entered: " << number << endl;
        break;
    }
    
    return 0;
}
```

### 2. Filtering Data
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> numbers = {1, -2, 3, -4, 5, 0, 7, -8, 9};
    
    cout << "Positive numbers only: ";
    for(int num : numbers) {
        if(num <= 0) {
            continue; // Skip non-positive numbers
        }
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}

// Output: Positive numbers only: 1 3 5 7 9
```

### 3. Menu Systems
```cpp
#include <iostream>
using namespace std;

int main() {
    char choice;
    
    while(true) {
        cout << "\n=== Menu ===" << endl;
        cout << "a) Option A" << endl;
        cout << "b) Option B" << endl;
        cout << "q) Quit" << endl;
        cout << "Choose: ";
        
        cin >> choice;
        
        if(choice == 'q' || choice == 'Q') {
            break;
        }
        
        if(choice != 'a' && choice != 'A' && 
           choice != 'b' && choice != 'B') {
            cout << "Invalid choice!" << endl;
            continue; // Skip to menu display
        }
        
        // Process valid choices
        switch(choice) {
            case 'a': case 'A':
                cout << "You chose Option A" << endl;
                break;
            case 'b': case 'B':
                cout << "You chose Option B" << endl;
                break;
        }
    }
    
    cout << "Goodbye!" << endl;
    return 0;
}
```

---

## Best Practices

### ✅ Do:
1. **Use continue for cleaner code**: When you have complex conditions that would require deep nesting
2. **Ensure loop variables are updated**: Especially in while loops, update variables before continue
3. **Consider readability**: Sometimes restructuring with if-else is clearer than continue
4. **Extract nested loops**: Put complex nested loops in separate functions

### ❌ Don't:
1. **Overuse continue**: Can make code harder to follow
2. **Forget variable updates**: Particularly dangerous in while loops - can cause infinite loops
3. **Use goto for nested continues**: Don't use goto, just to exist from a loop. Some say never use goto at all

---

## Continue vs Break

| Aspect | Continue | Break |
|--------|----------|-------|
| **Action** | Skip current iteration | Exit entire loop |
| **Control Flow** | Jump to next iteration | Jump after loop |
| **Use Case** | Skip specific conditions | Stop loop completely |

---

## Performance Considerations

Continue statements have minimal performance impact. The choice between continue and conditional blocks should be based on:
- Code readability
- Logic clarity
- Maintenance considerations

Choose the approach that makes your intent clearest to future readers of your code.