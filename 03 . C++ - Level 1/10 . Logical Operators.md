---
DATE: 2025-09-20T06:34:00
DONE: true
---



# 11. Logical Operators in C++



##  What are Logical Operators?

Logical operators provide us with the capability to test multiple conditions, allowing you to combine or modify Boolean expressions to create more complex decision-making logic.

When using the logical operators, C++ only evaluates what is necessary from left to right to come up with the combined relational result, ignoring the rest. This is called **short-circuit evaluation**.

## ðŸ“‹ Logical Operators Table

| Operator | Name        | Description                                        | Example               | Result  |
| -------- | ----------- | -------------------------------------------------- | --------------------- | ------- |
| `&&`     | Logical AND | Returns `true` only if **both** operands are true  | `(5 > 3) && (2 < 4)`  | `true`  |
| \|\|     | Logical OR  | Returns `true` if **at least one** operand is true | (5 > 10) \|\| (2 < 4) | `true`  |
| `!`      | Logical NOT | **Flips** the boolean value (true â†” false)         | `!(5 > 3)`            | `false` |

##  Truth Tables for Visual Understanding

### AND (&&) Operator Truth Table
```
A     B     A && B
--------------------
0     0       0
0     1       0
1     0       0
1     1       1
```
**Remember**: AND needs **BOTH** to be true!

### OR (||) Operator Truth Table  
```
A     B     A || B
--------------------
0     0       0
0     1       1
1     0       1
1     1       1
```
**Remember**: OR needs **AT LEAST ONE** to be true!

### NOT (!) Operator Truth Table
```
A     !A
----------
0      1
1      0
```
**Remember**: NOT **flips** the value!

##  Real-World Examples

### Example 1: Basic Logic Operations
```c++
#include <iostream>
using namespace std;

int main()
{
    bool isRaining = true;
    bool haveUmbrella = false;
    bool isSunny = false;
    
    // AND: Need BOTH conditions
    cout << "Go outside if sunny AND not raining: " 
         << (isSunny && !isRaining) << endl;  // 0 (false)
    
    // OR: Need AT LEAST ONE condition  
    cout << "Stay inside if raining OR no umbrella: " 
         << (isRaining || !haveUmbrella) << endl;  // 1 (true)
    
    // NOT: Flip the condition
    cout << "Is it NOT raining? " 
         << (!isRaining) << endl;  // 0 (false)
         
    return 0;
}
```

### Example 2: Age and License Check
```c++
#include <iostream>
using namespace std;

int main()
{
    int age = 17;
    bool hasLicense = false;
    bool hasPermit = true;
    
    // Can drive if: (18+ AND has license) OR (under 18 AND has permit)
    bool canDrive = (age >= 18 && hasLicense) || (age < 18 && hasPermit);
    
    cout << "Can drive: " << canDrive << endl;  // 1 (true)
    
    // Complex condition with parentheses for clarity
    bool canDriveAlone = (age >= 18) && (hasLicense || hasPermit);
    cout << "Can drive alone: " << canDriveAlone << endl;  // 0 (false)
    
    return 0;
}
```

## âš¡ Short-Circuit Evaluation

Short circuit evaluation presents another opportunity to show why operators that cause side effects should not be used in compound expressions.

```cpp
#include <iostream>
using namespace std;

int main()
{
    int x = 5;
    
    // In AND: if first is false, second is NOT evaluated
    if (x > 10 && ++x > 6) {  // ++x never executes because x > 10 is false
        cout << "This won't print" << endl;
    }
    cout << "x is still: " << x << endl;  // x is still 5
    
    // In OR: if first is true, second is NOT evaluated  
    if (x > 3 || ++x > 6) {   // ++x never executes because x > 3 is true
        cout << "This will print" << endl;
    }
    cout << "x is still: " << x << endl;  // x is still 5
    
    return 0;
}
```

##  Practice Examples

### Example 3: Number Range Check
```cpp
#include <iostream>
using namespace std;

int main()
{
    int number = 25;
    
    // Check if number is between 10 and 30 (inclusive)
    bool inRange = (number >= 10) && (number <= 30);
    cout << number << " is in range [10-30]: " << inRange << endl;
    
    // Check if number is outside the range 20-40
    bool outsideRange = (number < 20) || (number > 40);
    cout << number << " is outside range [20-40]: " << outsideRange << endl;
    
    return 0;
}
```

### Example 4: Login Validation
```cpp
#include <iostream>
using namespace std;

int main()
{
    string username = "admin";
    string password = "1234";
    bool accountActive = true;
    int loginAttempts = 2;
    
    // Login successful if: correct credentials AND account active AND attempts < 3
    bool loginSuccess = (username == "admin" && password == "1234") && 
                       accountActive && 
                       (loginAttempts < 3);
                       
    cout << "Login successful: " << loginSuccess << endl;
    
    // Account locked if: too many attempts OR account not active
    bool accountLocked = (loginAttempts >= 3) || (!accountActive);
    cout << "Account locked: " << accountLocked << endl;
    
    return 0;
}
```

## âš ï¸ Common Mistakes to Avoid

### 1. Operator Precedence
```cpp
// WRONG: ! has higher precedence than >
if (!x > y)  // This means (!x) > y

// CORRECT: Use parentheses  
if (!(x > y))  // This means NOT(x > y)
```

### 2. Side Effects in Conditions
```cpp
// DANGEROUS: ++count might not execute due to short-circuiting
if (x > 5 && ++count < 10) { }

// BETTER: Separate the increment
++count;
if (x > 5 && count < 10) { }
```

## ðŸ”— De Morgan's Laws

De Morgan's laws tell us how the logical NOT should be distributed:

- `!(A && B)` is equivalent to `!A || !B`
- `!(A || B)` is equivalent to `!A && !B`

```cpp
int a = 5, b = 10;

// These are equivalent:
!(a > 3 && b < 15)  // NOT(both conditions)
// Same as:
!(a > 3) || !(b < 15)  // Either condition is false
```

##  Key Takeaways

1. **AND (&&)**: All conditions must be true
2. **OR (||)**: At least one condition must be true  
3. **NOT (!)**: Flips true/false values
4. **Short-circuiting**: Stops evaluation when result is determined
5. **Use parentheses**: Makes complex expressions clear and prevents precedence errors
6. **Avoid side effects**: Don't use ++/-- in logical expressions
