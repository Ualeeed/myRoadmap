

##  What are Template Functions?

Template functions allow you to write a single function that can work with multiple data types without rewriting the code for each type. Think of them as a **blueprint** or **recipe** that the compiler uses to automatically generate different versions of the same function for different data types.

## ğŸª The Cookie Cutter Analogy

Imagine a cookie cutter:
- **Template** = The cookie cutter shape (â­)
- **Dough types** = Different data types (chocolate, vanilla, strawberry)
- **Cookies** = Actual functions generated by compiler

```
          Template Function (Cookie Cutter)
                    â­
                    â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â†“               â†“               â†“
int function   double function  string function
```

##  Problem Without Templates

**Without templates, you need separate functions for each type:**

```cpp
// Function for integers
int maximum(int a, int b) {
    return (a > b) ? a : b;
}

// Function for doubles - SAME CODE!
double maximum(double a, double b) {
    return (a > b) ? a : b;
}

// Function for strings - SAME CODE AGAIN!
string maximum(string a, string b) {
    return (a > b) ? a : b;
}

// This is repetitive and hard to maintain! ğŸ˜«
```

## ğŸš€ Solution With Templates

**With templates, you write it ONCE:**

```cpp
template <typename T>
T maximum(T a, T b) {
    return (a > b) ? a : b;
}

// Now works with ANY type! ğŸ‰
int x = maximum(5, 10);           // T = int
double y = maximum(3.5, 2.1);     // T = double
string z = maximum("hello", "world"); // T = string
```

## ğŸ”§ Basic Syntax

### Template Function Structure

```cpp
 template <typename T>
 return_type function_name(parameters) {
    // function body
 }
```

**Breaking it down:**
```
template <typename T>  â†’ Tells compiler this is a template
    â†“
    T = Placeholder for any data type
    
You can use: typename or class (both work the same)
template <typename T> âœ…
template <class T>    âœ… (same thing!)
```

## ğŸ“ Simple Examples

### Example 1: Basic Template Function

```cpp
#include <iostream>
using namespace std;

// Template function to display any value
template <typename T>
void display(T value) {
    cout << "Value: " << value << endl;
}

int main() {
    display(42);          // T = int
    display(3.14);        // T = double
    display("Hello");     // T = const char*
    display('A');         // T = char
    
    return 0;
}
```

**Output:**
```
Value: 42
Value: 3.14
Value: Hello
Value: A
```

### Example 2: Swap Function

```cpp
template <typename T>
void swap(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 5, y = 10;
    swap(x, y);
    cout << x << " " << y << endl;  // 10 5
    
    double p = 1.5, q = 2.5;
    swap(p, q);
    cout << p << " " << q << endl;  // 2.5 1.5
    
    return 0;
}
```

**Visual Swap Process:**
```
Before: x=5, y=10
Step 1: temp = x      â†’ temp=5
Step 2: x = y         â†’ x=10
Step 3: y = temp      â†’ y=5
After:  x=10, y=5  âœ“
```

## ğŸ¨ Multiple Template Parameters

You can use multiple type parameters in a single template:

```cpp
template <typename T1, typename T2>
void displayPair(T1 first, T2 second) {
    cout << "First: " << first << endl;
    cout << "Second: " << second << endl;
}

int main() {
    displayPair(10, 3.14);           // T1=int, T2=double
    displayPair("Name", 25);         // T1=const char*, T2=int
    displayPair(true, "Success");    // T1=bool, T2=const char*
    
    return 0;
}
```

## ğŸ” How the Compiler Works

### Template Instantiation Process

```
1. You write template:
   template <typename T>
   T add(T a, T b) { return a + b; }

2. You call it:
   int result = add(5, 3);

3. Compiler generates:
   int add(int a, int b) { return a + b; }
   
4. Compiler compiles the generated function
   
5. Program runs with the specific function
```

**Visual Process:**
```
Your Code:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ template <typename T>  â”‚
â”‚ T maximum(T a, T b)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
    Compiler sees:
    maximum(5, 10)
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Generates:             â”‚
â”‚ int maximum(int, int)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
    Executable Code
```

##  **Practical Examples

### Example 1: Find Maximum of Three Values

```cpp
template <typename T>
T findMax(T a, T b, T c) {
    T max = a;
    if (b > max) max = b;
    if (c > max) max = c;
    return max;
}

int main() {
    cout << findMax(3, 7, 5) << endl;          // 7
    cout << findMax(1.5, 9.8, 3.2) << endl;    // 9.8
    cout << findMax('a', 'z', 'm') << endl;    // z
    
    return 0;
}
```

### Example 2: Array Sum Function

```cpp
template <typename T>
T arraySum(T arr[], int size) {
    T sum = 0;
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum;
}

int main() {
    int intArr[] = {1, 2, 3, 4, 5};
    double doubleArr[] = {1.1, 2.2, 3.3};
    
    cout << "Int sum: " << arraySum(intArr, 5) << endl;        // 15
    cout << "Double sum: " << arraySum(doubleArr, 3) << endl;  // 6.6
    
    return 0;
}
```

### Example 3: Generic Calculator

```cpp
#include <iostream>
using namespace std;

template <typename T>
class Calculator {
public:
    T add(T a, T b) { return a + b; }
    T subtract(T a, T b) { return a - b; }
    T multiply(T a, T b) { return a * b; }
    T divide(T a, T b) { return a / b; }
};

int main() {
    Calculator<int> intCalc;
    cout << "5 + 3 = " << intCalc.add(5, 3) << endl;        // 8
    cout << "10 - 4 = " << intCalc.subtract(10, 4) << endl; // 6
    
    Calculator<double> doubleCalc;
    cout << "5.5 * 2 = " << doubleCalc.multiply(5.5, 2) << endl;  // 11
    cout << "10.0 / 3 = " << doubleCalc.divide(10.0, 3) << endl;  // 3.33333
    
    return 0;
}
```

## ğŸ¯ Explicit Type Specification

Sometimes you need to explicitly tell the compiler which type to use:

```cpp
template <typename T>
T getValue() {
    return T();  // Return default value of type T
}

int main() {
    // Must specify type explicitly
    int x = getValue<int>();        // Returns 0
    double y = getValue<double>();  // Returns 0.0
    
    // Cannot deduce type from parameters
    // int z = getValue();  âŒ Error!
    
    return 0;
}
```

## ğŸ“Š Template vs Regular Function

| Feature | Regular Function | Template Function |
|---------|------------------|-------------------|
| Code reuse | âŒ Separate function per type | âœ… One template for all types |
| Flexibility | âŒ Fixed type | âœ… Works with any type |
| Compile time | âœ… Faster | âš ï¸ Generates code per type |
| Binary size | âœ… Smaller | âš ï¸ Larger (multiple versions) |
| Debugging | âœ… Easier | âš ï¸ Complex error messages |

## âš ï¸ Important Considerations

### 1. Type Requirements

The type used with template must support the operations used in the function:

```cpp
template <typename T>
T add(T a, T b) {
    return a + b;  // T must support + operator
}

// Works:
int x = add(5, 3);           âœ…
double y = add(1.5, 2.5);    âœ…

// Error if type doesn't support +:
// MyClass obj = add(obj1, obj2);  âŒ unless + is overloaded
```

### 2. Template Definition Location

Templates must be defined in header files (.h) because the compiler needs to see the definition when instantiating:

```cpp
// MyTemplate.h
template <typename T>
T multiply(T a, T b) {
    return a * b;
}
// âœ… Definition in header file
```

### 3. Compiler Error Messages

Template errors can be verbose and hard to understand:

```cpp
template <typename T>
T divide(T a, T b) {
    return a / b;
}

// Error with string:
string result = divide("hello", "world");  
// âŒ Long, confusing error message!
```

## ğŸŒŸ Real-World Use Cases

1. **STL Containers**: vector, map, set all use templates
   ```cpp
   vector<int> numbers;
   vector<string> names;
   ```

2. **Smart Pointers**: unique_ptr, shared_ptr
   ```cpp
   unique_ptr<int> ptr;
   ```

3. **Algorithms**: sort, find, count
   ```cpp
   sort(vec.begin(), vec.end());
   ```

4. **Generic Data Structures**: Stack, Queue, LinkedList
   ```cpp
   Stack<int> intStack;
   Stack<string> stringStack;
   ```

## ğŸ“ Quick Reference

```cpp
// Basic template
template <typename T>
T function(T param) { /* ... */ }

// Multiple parameters
template <typename T1, typename T2>
void function(T1 a, T2 b) { /* ... */ }

// Explicit specification
function<int>(value);

// Class template
template <typename T>
class MyClass {
    T value;
};

// Usage
MyClass<int> obj;
```

## ğŸ“ Common Template Patterns

### Pattern 1: Type Deduction
```cpp
template <typename T>
T max(T a, T b) { return (a > b) ? a : b; }

max(5, 10);      // T automatically deduced as int
```

### Pattern 2: Explicit Specification
```cpp
template <typename T>
T convert() { return T(); }

int x = convert<int>();  // Must specify type
```

### Pattern 3: Multiple Types
```cpp
template <typename T1, typename T2>
auto add(T1 a, T2 b) -> decltype(a + b) {
    return a + b;
}

add(5, 3.14);  // Returns double (5.0 + 3.14)
```

## âœ… Best Practices

1. âœ… Use meaningful template parameter names (T for single type, T1/T2 for multiple)
2. âœ… Document type requirements in comments
3. âœ… Keep templates simple and focused
4. âœ… Test with different data types
5. âœ… Put template definitions in header files
6. âš ï¸ Be aware of code bloat (compiler generates code for each type)
7. âš ï¸ Watch out for long compilation times with complex templates

## ğŸ”— Key Takeaways

1. ğŸ¯ Templates enable **generic programming**
2. ğŸ“ Write code **once**, use with **any type**
3. ğŸ”§ Compiler generates **specific functions** at compile time
4. ğŸ’ª Foundation of **C++ STL**
5. ğŸ¨ Powerful but requires understanding of type requirements

---

