---
DATE: 2025-10-23T17:27:00
DONE: true
Name: OOP
---


## What is a Copy Constructor?

A **copy constructor** is a special constructor that creates a new object by copying the contents of an existing object of the same class. It's a fundamental concept in C++ that handles object duplication and is crucial for proper resource management.

## Key Characteristics

### üî∏ Basic Properties
- **Parameter**: Takes a reference to an object of the same class (usually `const` reference)
- **Purpose**: Initialize a new object as a copy of an existing object
- **Automatic generation**: Compiler provides a default copy constructor if you don't define one
- **Deep vs Shallow copying**: Default is shallow; you may need deep copying for dynamic resources

### üî∏ Signature Format
```cpp
ClassName(const ClassName& other)  // Preferred: const reference
ClassName(ClassName& other)        // Valid but less preferred
```

## When Copy Constructors are Called

### 1. Object Initialization with Another Object
```cpp
MyClass obj1(10);        // Regular constructor
MyClass obj2(obj1);      // Copy constructor called
MyClass obj3 = obj1;     // Copy constructor called (not assignment!)
```

### 2. Pass by Value to Function
```cpp
void processObject(MyClass obj) {  // Copy constructor called
    // Function body
}

MyClass original(5);
processObject(original);  // original is copied to parameter obj
```

### 3. Return by Value from Function
```cpp
MyClass createObject() {
    MyClass temp(10);
    return temp;  // Copy constructor may be called (subject to optimization)
}
```

## Shallow Copy vs Deep Copy

### üî∏ Shallow Copy (Default Behavior)
The default copy constructor performs **memberwise copying** - it copies the values of all member variables.

```cpp
class SimpleClass {
private:
    int value;
    double rate;
    
public:
    SimpleClass(int v, double r) : value(v), rate(r) {}
    
    // Default copy constructor (implicit):
    // SimpleClass(const SimpleClass& other) : value(other.value), rate(other.rate) {}
    
    void display() const {
        std::cout << "Value: " << value << ", Rate: " << rate << std::endl;
    }
};
```

### üî∏ Deep Copy (Custom Implementation Needed)
When your class manages dynamic resources, you need a **custom copy constructor** for deep copying.

```cpp
class StringWrapper {
private:
    char* str;
    size_t length;

public:
    // Constructor
    StringWrapper(const char* s) {
        length = strlen(s);
        str = new char[length + 1];
        strcpy(str, s);
        std::cout << "String created: " << str << std::endl;
    }
    
    // ‚ùå Without custom copy constructor, this would cause problems:
    // - Both objects would point to the same memory
    // - Double deletion when destructors are called
    // - Undefined behavior
    
    // ‚úÖ Custom copy constructor (Deep Copy)
    StringWrapper(const StringWrapper& other) : length(other.length) {
        str = new char[length + 1];  // Allocate new memory
        strcpy(str, other.str);      // Copy the actual string content
        std::cout << "String copied: " << str << std::endl;
    }
    
    // Destructor
    ~StringWrapper() {
        delete[] str;
        std::cout << "String destroyed" << std::endl;
    }
    
    // Getter
    const char* getString() const { return str; }
    
    void display() const {
        std::cout << "String: " << str << " (Address: " << (void*)str << ")" << std::endl;
    }
};
```

## Constructor Overloading with Copy Constructor

```cpp
class Rectangle {
private:
    double width;
    double height;
    std::string name;

public:
    // Default constructor
    Rectangle() : width(1.0), height(1.0), name("Default Rectangle") {
        std::cout << "Default constructor called\n";
    }
    
    // Parameterized constructor
    Rectangle(double w, double h, const std::string& n) 
        : width(w), height(h), name(n) {
        std::cout << "Parameterized constructor called for: " << name << "\n";
    }
    
    // Copy constructor
    Rectangle(const Rectangle& other) 
        : width(other.width), height(other.height), name(other.name + " (Copy)") {
        std::cout << "Copy constructor called for: " << name << "\n";
    }
    
    // Additional constructor overloads
    Rectangle(double side) : Rectangle(side, side, "Square") {  // Delegating constructor
        std::cout << "Square constructor (delegates to parameterized)\n";
    }
    
    double area() const { return width * height; }
    
    void display() const {
        std::cout << "Rectangle '" << name << "': " 
                  << width << " x " << height 
                  << " (Area: " << area() << ")\n";
    }
    
    // Setter methods
    void setDimensions(double w, double h) {
        width = w;
        height = h;
    }
};
```

## Enhanced Address Example with Copy Constructor

```cpp
#include <iostream>
#include <string>
#include <memory>

class Address {
private:
    std::string addressLine1;
    std::string addressLine2;
    std::string poBox;
    std::string zipCode;
    mutable int copyCount;  // Track how many times this address has been copied

public:
    // Default constructor
    Address() : addressLine1(""), addressLine2(""), poBox(""), zipCode(""), copyCount(0) {
        std::cout << "Address: Default constructor called\n";
    }
    
    // Parameterized constructor
    Address(const std::string& line1, const std::string& line2, 
            const std::string& po, const std::string& zip) 
        : addressLine1(line1), addressLine2(line2), poBox(po), zipCode(zip), copyCount(0) {
        std::cout << "Address: Parameterized constructor called\n";
    }
    
    // Copy constructor with additional logic
    Address(const Address& other) 
        : addressLine1(other.addressLine1)
        , addressLine2(other.addressLine2)
        , poBox(other.poBox)
        , zipCode(other.zipCode)
        , copyCount(0)  // New copy starts with count 0
    {
        other.copyCount++;  // Increment the original's copy count
        std::cout << "Address: Copy constructor called (Original has been copied " 
                  << other.copyCount << " times)\n";
    }
    
    // Move constructor (C++11 feature)
    Address(Address&& other) noexcept 
        : addressLine1(std::move(other.addressLine1))
        , addressLine2(std::move(other.addressLine2))
        , poBox(std::move(other.poBox))
        , zipCode(std::move(other.zipCode))
        , copyCount(other.copyCount)
    {
        other.copyCount = 0;
        std::cout << "Address: Move constructor called\n";
    }
    
    // Copy assignment operator (completing the Rule of Three/Five)
    Address& operator=(const Address& other) {
        if (this != &other) {  // Self-assignment check
            addressLine1 = other.addressLine1;
            addressLine2 = other.addressLine2;
            poBox = other.poBox;
            zipCode = other.zipCode;
            // Don't copy copyCount in assignment
            other.copyCount++;
            std::cout << "Address: Copy assignment operator called\n";
        }
        return *this;
    }
    
    // Getters
    const std::string& getAddressLine1() const { return addressLine1; }
    const std::string& getAddressLine2() const { return addressLine2; }
    const std::string& getPoBox() const { return poBox; }
    const std::string& getZipCode() const { return zipCode; }
    int getCopyCount() const { return copyCount; }
    
    // Utility methods
    void display() const {
        std::cout << "\n=== Address Details ===\n";
        std::cout << "Address Line 1: " << addressLine1 << "\n";
        if (!addressLine2.empty()) {
            std::cout << "Address Line 2: " << addressLine2 << "\n";
        }
        if (!poBox.empty()) {
            std::cout << "PO Box: " << poBox << "\n";
        }
        std::cout << "Zip Code: " << zipCode << "\n";
        std::cout << "Times Copied: " << copyCount << "\n";
        std::cout << "Object Address: " << this << "\n";
        std::cout << "=====================\n";
    }
    
    bool isEmpty() const {
        return addressLine1.empty() && zipCode.empty();
    }
    
    // Create a modified copy
    Address withNewZip(const std::string& newZip) const {
        Address copy(*this);  // Use copy constructor
        copy.zipCode = newZip;
        return copy;  // Return by value (copy/move constructor may be called)
    }
};

// Demonstration functions
void demonstrateCopyBehavior(Address addr) {  // Parameter passed by value
    std::cout << "Inside function - received copy:\n";
    addr.display();
}

Address createSampleAddress() {
    Address temp("123 Sample St", "Unit A", "PO Box 456", "12345");
    return temp;  // Return by value
}

int main() {
    std::cout << "=== Copy Constructor Demonstration ===\n\n";
    
    // 1. Original object creation
    std::cout << "1. Creating original address:\n";
    Address original("Morocco, Midelt", "Place Vert", "1998", "5555");
    original.display();
    
    // 2. Copy initialization
    std::cout << "\n2. Copy initialization:\n";
    Address copy1 = original;  // Copy constructor called
    copy1.display();
    
    // 3. Copy constructor with explicit call
    std::cout << "\n3. Explicit copy constructor call:\n";
    Address copy2(original);   // Copy constructor called
    copy2.display();
    
    // 4. Pass by value to function
    std::cout << "\n4. Passing to function by value:\n";
    demonstrateCopyBehavior(original);
    original.display();  // Check if copy count increased
    
    // 5. Return by value from function
    std::cout << "\n5. Return by value from function:\n";
    Address returned = createSampleAddress();
    returned.display();
    
    // 6. Creating modified copy
    std::cout << "\n6. Creating modified copy:\n";
    Address modifiedCopy = original.withNewZip("99999");
    modifiedCopy.display();
    original.display();  // Original should show increased copy count
    
    // 7. Assignment vs Copy Construction
    std::cout << "\n7. Assignment vs Copy Construction:\n";
    Address assigned;          // Default constructor
    assigned = original;       // Copy assignment operator (not copy constructor!)
    assigned.display();
    
    return 0;
}
```

## Rule of Three/Five/Zero

When you define a copy constructor, you typically need to also define:

### üî∏ Rule of Three (C++98)
1. **Copy Constructor**
2. **Copy Assignment Operator**
3. **Destructor**

### üî∏ Rule of Five (C++11)
Adds move semantics:
4. **Move Constructor**
5. **Move Assignment Operator**

### üî∏ Rule of Zero
If you don't need custom resource management, don't define any of these - let the compiler generate them.

```cpp
class ModernClass {
private:
    std::string name;
    std::vector<int> data;
    std::unique_ptr<int> ptr;

public:
    // Rule of Zero: Use smart pointers and standard containers
    // Compiler-generated copy constructor, assignment, destructor work correctly
    
    ModernClass(const std::string& n) : name(n), data{1, 2, 3}, ptr(std::make_unique<int>(42)) {}
    
    // No need to define copy constructor, assignment operator, or destructor
    // The compiler-generated versions handle everything correctly
};
```

## Performance Considerations

### üî∏ Copy Elision and RVO (Return Value Optimization)
Modern compilers can eliminate unnecessary copying:

```cpp
Address createAddress() {
    return Address("123 St", "", "", "12345");  // May be optimized (no copy)
}

Address addr = createAddress();  // Potential optimization
```

### üî∏ Move Semantics (C++11+)
Prefer move operations when possible:

```cpp
std::vector<Address> addresses;
addresses.push_back(std::move(myAddress));  // Move instead of copy
```

## Common Pitfalls and Best Practices

### ‚ùå Common Mistakes
1. **Forgetting const in copy constructor parameter**
2. **Shallow copying when deep copying is needed**
3. **Self-assignment in copy assignment operator**
4. **Not implementing copy assignment when implementing copy constructor**

### ‚úÖ Best Practices
1. **Use `const` reference parameter**: `const ClassName& other`
2. **Initialize members in initializer list** for efficiency
3. **Consider move semantics** in modern C++ (C++11+)
4. **Follow Rule of Three/Five** when managing resources
5. **Use smart pointers** to simplify resource management
6. **Consider making copy constructor `explicit`** if copying should be intentional
7. **Document the copying behavior** of your classes

## Advanced Copy Constructor Features

### üî∏ Deleted Copy Constructor
Prevent copying when it doesn't make sense:

```cpp
class NonCopyable {
public:
    NonCopyable() = default;
    NonCopyable(const NonCopyable&) = delete;            // No copy constructor
    NonCopyable& operator=(const NonCopyable&) = delete; // No copy assignment
};
```

### üî∏ Explicit Copy Constructor
Make copying intentional:

```cpp
class ExpensiveToCopy {
public:
    explicit ExpensiveToCopy(const ExpensiveToCopy& other) {
        // Expensive copying operation
    }
};

// ExpensiveToCopy obj2 = obj1;     // Error: implicit conversion not allowed
ExpensiveToCopy obj2(obj1);         // OK: explicit copy
```

Copy constructors are essential for proper C++ programming, especially when dealing with classes that manage resources. Understanding when they're called and how to implement them correctly is crucial for writing robust, efficient C++ code.