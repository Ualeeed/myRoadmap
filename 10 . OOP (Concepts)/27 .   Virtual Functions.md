---
DATE: 2025-08-29T00:17:00
DONE: true
Name: OOP
---
 
- A <span style="color:rgb(20, 192, 255)">virtual</span> function is a member function in the base class that we expect to redefine in derived classes.
- Basically, a <span style="color:rgb(20, 192, 255)">virtual</span> function is used in the base class in order to ensure that the function is overridden. This especially applies to cases where a pointer of base class points to an object of a derived class.

```cpp
#include <iostream>

using namespace std;

class clsPerson
{

public:

  virtual void Print()
  {
        cout << "Hi, i'm a person!\n ";
    
  }

};

class clsEmployee : public clsPerson
{
public:
    void Print()
    {
        cout << "Hi, I'm an Employee\n";
    }
};

class clsStudent : public clsPerson
{
public:
     void Print() 
    {
        cout << "Hi, I'm a student\n";
    }
};


int main()

{

    clsEmployee Employee1;
    clsStudent  Student1;

   Employee1.Print();
    Student1.Print();


   
    clsPerson * Person1 = &Employee1;
    clsPerson * Person2 = &Student1;

    Person1->Print();
    Person2->Print();


    system("pause>0");
    return 0;
}
```



### Without `virtual`

When you define a function inside a <span style="color:rgb(0, 176, 80)">base class</span> and then override it in a <span style="color:rgb(0, 176, 80)">derived class</span>, **the function that gets called depends on the type of the pointer/reference at compile-time**, not the actual object stored inside.

```cpp
clsPerson* Person1 = &Employee1;
Person1->Print();   // ❌ will call clsPerson::Print (NOT Employee version)
```

- Because `Person1` is of type `clsPerson*`, and without `virtual`, the compiler binds the call to the base class function at **compile-time** (this is called **static binding / early binding**).


### With `virtual`

When you add the `virtual` keyword to a function in the base class:

```c++
virtual void Print()
{
    cout << "Hi, I'm a Person!\n";
}

```

Now C++ uses **dynamic dispatch** (also called **late binding** or **runtime polymorphism**).  
This means the function call depends on the **actual type of the object at runtime**, not just the type of the pointer.

So in your code:


```cpp
clsPerson * Person1 = &Employee1;
clsPerson * Person2 = &Student1;

Person1->Print();  // ✅ calls Employee's Print()
Person2->Print();  // ✅ calls Student's Print()

```

#### Summary : 

- `virtual` tells C++: "This function may be overridden in derived classes. Always check the object’s actual type at runtime before deciding which function to call."
    
- Without `virtual` → function call decided at compile time.
    
- With `virtual` → function call decided at runtime (polymorphism).