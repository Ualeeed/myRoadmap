---
DATE: 2025-10-23T17:11:00
DONE: true
Name: OOP
---


## What is a Constructor?

A **constructor** is a special member function that is automatically invoked when an object of a class is created. It serves as the initialization mechanism for objects, ensuring that they start with valid and meaningful data.

## Key Characteristics of Constructors

### ðŸ”¸ Basic Properties
- **Same name as the class** - This is how the compiler identifies it as a constructor
- **No return type** - Not even `void`; constructors don't return anything
- **Automatic invocation** - Called automatically during object creation
- **Can be overloaded** - Multiple constructors with different parameter lists

### ðŸ”¸ Primary Purposes
1. **Initialize member variables** with appropriate values
2. **Allocate memory** if needed (dynamic allocation)
3. **Perform setup operations** required for the object
4. **Establish invariants** - ensure object is in a valid state

## Types of Constructors

### 1. Default Constructor
A constructor with **no parameters** or all parameters have **default values**.

```cpp
class Student {
private:
    string name;
    int age;
    double gpa;

public:
    // Default constructor
    Student() {
        name = "Unknown";
        age = 0;
        gpa = 0.0;
        cout << "Default constructor called\n";
    }
    
    // Alternative with default parameters
    Student(string n = "Unknown", int a = 0, double g = 0.0) 
        : name(n), age(a), gpa(g) {
        cout << "Constructor with defaults called\n";
    }
};
```

### 2. Parameterized Constructor
A constructor that accepts parameters to initialize the object with specific values.

```cpp
class Student {
private:
    string name;
    int age;
    double gpa;

public:
    // Parameterized constructor using initializer list (preferred)
    Student(string n, int a, double g) : name(n), age(a), gpa(g) {
        cout << "Parameterized constructor called for: " << name << "\n";
    }
    
    // Alternative using assignment in body (less efficient)
    Student(string n, int a, double g) {
        name = n;
        age = a;
        gpa = g;
    }
};
```

## Constructor Overloading

You can have multiple constructors with different parameter signatures:

```cpp
class Rectangle {
private:
    double width, height;

public:
    // Default constructor
    Rectangle() : width(1.0), height(1.0) {}
    
    // Square constructor (one parameter)
    Rectangle(double side) : width(side), height(side) {}
    
    // Rectangle constructor (two parameters)
    Rectangle(double w, double h) : width(w), height(h) {}
    
    // Copy constructor (covered in next section)
    Rectangle(const Rectangle& other) : width(other.width), height(other.height) {}
    
    void display() const {
        cout << "Rectangle: " << width << " x " << height << endl;
    }
};
```

## Member Initializer List vs Assignment

### âœ… Preferred: Member Initializer List
```cpp
class Point {
private:
    const int x;  // const member must be initialized
    int& y_ref;   // reference member must be initialized
    string name;

public:
    // Using initializer list (efficient and required for const/reference members)
    Point(int x_val, int& y_val, string n) : x(x_val), y_ref(y_val), name(n) {}
};
```

### âŒ Less Efficient: Assignment in Constructor Body
```cpp
class Point {
private:
    int x;
    string name;

public:
    Point(int x_val, string n) {
        x = x_val;      // Assignment after default initialization
        name = n;       // String is default-constructed then assigned
    }
};
```

## Enhanced Address Example with Best Practices

```cpp
#include <iostream>
#include <string>
#include <stdexcept>

class Address {
private:
    std::string addressLine1;
    std::string addressLine2;
    std::string poBox;
    std::string zipCode;
    
    // Helper function to validate zip code
    bool isValidZipCode(const std::string& zip) const {
        return !zip.empty() && zip.length() >= 4;
    }

public:
    // Default constructor
    Address() : addressLine1(""), addressLine2(""), poBox(""), zipCode("") {
        std::cout << "Address: Default constructor called\n";
    }
    
    // Parameterized constructor with validation
    Address(const std::string& line1, const std::string& line2, 
            const std::string& po, const std::string& zip) 
        : addressLine1(line1), addressLine2(line2), poBox(po), zipCode(zip) {
        
        if (!isValidZipCode(zip)) {
            throw std::invalid_argument("Invalid zip code provided");
        }
        std::cout << "Address: Parameterized constructor called\n";
    }
    
    // Constructor with minimal required information
    Address(const std::string& line1, const std::string& zip) 
        : addressLine1(line1), addressLine2(""), poBox(""), zipCode(zip) {
        
        if (!isValidZipCode(zip)) {
            throw std::invalid_argument("Invalid zip code provided");
        }
        std::cout << "Address: Minimal constructor called\n";
    }
    
    // Getters (const methods)
    const std::string& getAddressLine1() const { return addressLine1; }
    const std::string& getAddressLine2() const { return addressLine2; }
    const std::string& getPoBox() const { return poBox; }
    const std::string& getZipCode() const { return zipCode; }
    
    // Setters with validation
    void setAddressLine1(const std::string& line1) {
        if (line1.empty()) {
            throw std::invalid_argument("Address line 1 cannot be empty");
        }
        addressLine1 = line1;
    }
    
    void setZipCode(const std::string& zip) {
        if (!isValidZipCode(zip)) {
            throw std::invalid_argument("Invalid zip code format");
        }
        zipCode = zip;
    }
    
    // Display method
    void display() const {
        std::cout << "\n=== Address Details ===\n";
        std::cout << "Address Line 1: " << addressLine1 << "\n";
        if (!addressLine2.empty()) {
            std::cout << "Address Line 2: " << addressLine2 << "\n";
        }
        if (!poBox.empty()) {
            std::cout << "PO Box: " << poBox << "\n";
        }
        std::cout << "Zip Code: " << zipCode << "\n";
        std::cout << "=====================\n\n";
    }
    
    // Check if address is complete
    bool isComplete() const {
        return !addressLine1.empty() && !zipCode.empty();
    }
};

int main() {
    try {
        // Using different constructors
        Address addr1;  // Default constructor
        addr1.display();
        
        Address addr2("123 Main St", "12345");  // Minimal constructor
        addr2.display();
        
        Address addr3("456 Oak Ave", "Apt 2B", "PO Box 789", "67890");  // Full constructor
        addr3.display();
        
        std::cout << "Address 2 complete: " << (addr2.isComplete() ? "Yes" : "No") << "\n";
        std::cout << "Address 3 complete: " << (addr3.isComplete() ? "Yes" : "No") << "\n";
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

## Important Constructor Rules

### ðŸ”¸ Constructor Override Behavior
- When you define **any constructor**, the compiler **won't generate** a default constructor
- If you need both parameterized and default constructors, you must define both explicitly
- Use `= default` to explicitly request compiler-generated default constructor

```cpp
class MyClass {
public:
    MyClass() = default;  // Explicitly request default constructor
    MyClass(int value) : data(value) {}  // Custom constructor
    
private:
    int data = 0;  // In-class initialization as backup
};
```

### ðŸ”¸ Explicit Constructors
Use `explicit` keyword to prevent implicit conversions:

```cpp
class Distance {
private:
    double meters;

public:
    explicit Distance(double m) : meters(m) {}  // Prevents implicit conversion
    
    void display() const {
        std::cout << meters << " meters\n";
    }
};

int main() {
    Distance d1(100.0);     // âœ… OK: Direct initialization
    Distance d2 = Distance(100.0);  // âœ… OK: Explicit conversion
    // Distance d3 = 100.0;  // âŒ Error: Implicit conversion prevented
    
    return 0;
}
```

## Common Pitfalls and Best Practices

### âŒ Common Mistakes
1. **Forgetting to initialize const/reference members**
2. **Not using initializer lists for efficiency**
3. **Not validating input parameters**
4. **Memory leaks in constructors with dynamic allocation**

### âœ… Best Practices
1. **Use member initializer lists** whenever possible
2. **Validate parameters** and throw exceptions for invalid input
3. **Make single-parameter constructors explicit** unless implicit conversion is intended
4. **Initialize all members** to avoid undefined behavior
5. **Use const references** for string/object parameters to avoid unnecessary copying
6. **Follow RAII principle** (Resource Acquisition Is Initialization)

## Memory Management in Constructors

```cpp
class DynamicArray {
private:
    int* data;
    size_t size;

public:
    // Constructor with dynamic memory allocation
    explicit DynamicArray(size_t s) : size(s) {
        if (s == 0) {
            throw std::invalid_argument("Size must be greater than 0");
        }
        
        try {
            data = new int[size]();  // Allocate and zero-initialize
            std::cout << "Array of size " << size << " created\n";
        } catch (const std::bad_alloc& e) {
            std::cerr << "Memory allocation failed: " << e.what() << std::endl;
            throw;  // Re-throw the exception
        }
    }
    
    // Important: This class needs Rule of Three/Five implementation
    // (destructor, copy constructor, copy assignment operator)
    
    ~DynamicArray() {
        delete[] data;
        std::cout << "Array destroyed\n";
    }
};
```

Constructors are fundamental to proper object-oriented design in C++. They ensure that objects are properly initialized and ready for use immediately after creation, maintaining the integrity and reliability of your programs.