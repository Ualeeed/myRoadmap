 
## What Are Properties?

Properties in C++ are methods used to access and modify private member variables of a class, allowing for controlled access and modification of data. Think of them as gatekeepers that control how data enters and leaves your class.

## Why Do We Need Them?

### The Problem Without Properties

Imagine you have a `Skyscraper` class with a public `height` variable:

```c++
class Skyscraper {
public:
    double height;
};
```

Anyone can directly access and change the height, potentially assigning absurd values like negative numbers. This is bad practice!

### The Solution: Private Variables + Getter/Setter Methods

By placing the height into the private section, you can no longer change it directly, and must use accessor (get) and mutator (set) methods to access and modify it.

## Basic Structure

### Getter Method (Accessor)
- **Purpose**: Returns the value of a private variable
- **Naming**: Usually `get` + VariableName (e.g., `getHeight()`)
- **Return Type**: The type of the variable
- **Marked as `const`**: Indicates it won't modify the object

### Setter Method (Mutator)
- **Purpose**: Sets the value of a private variable
- **Naming**: Usually `set` + VariableName (e.g., `setHeight()`)
- **Return Type**: Usually `void`
- **Can include validation**: Check if the value is valid before setting

## Simple Example

Here's a basic example showing how to create getter and setter methods:

```cpp
#include <iostream>
using namespace std;

class Rectangle {
private:
    int length;  // Private data member
    int width;   // Private data member

public:
    // Constructor
    Rectangle(int len, int wid) {
        length = len;
        width = wid;
    }

    // Getter methods (const means they don't modify the object)
    int getLength() const {
        return length;
    }

    int getWidth() const {
        return width;
    }

    // Setter methods (allow validation before setting)
    void setLength(int len) {
        if (len > 0) {  // Validation
            length = len;
        }
    }

    void setWidth(int wid) {
        if (wid > 0) {  // Validation
            width = wid;
        }
    }
};

int main() {
    // Create a Rectangle object
    Rectangle rect(5, 3);

    // Use getter methods to read values
    cout << "Length: " << rect.getLength() << endl;
    cout << "Width: " << rect.getWidth() << endl;

    // Use setter methods to modify values
    rect.setLength(7);
    rect.setWidth(4);

    // Display updated values
    cout << "Updated Length: " << rect.getLength() << endl;
    cout << "Updated Width: " << rect.getWidth() << endl;

    return 0;
}
```

**Output:**
```
Length: 5
Width: 3
Updated Length: 7
Updated Width: 4
```

## Example with Validation

The setter method can include validation to ensure only valid values are assigned, using assertions to terminate the program if the value is invalid:

```cpp
#include <iostream>
#include <cassert>
using namespace std;

class Skyscraper {
private:
    double height;

public:
    // Setter with validation
    void setHeight(double h) {
        assert(h >= 0);  // Ensure height is non-negative
        height = h;
    }

    // Getter
    double getHeight() const {
        return height;
    }
};

int main() {
    Skyscraper building;
    
    building.setHeight(250.5);  // Valid
    cout << "Height: " << building.getHeight() << " meters" << endl;
    
    // building.setHeight(-100);  // This would trigger assertion error
    
    return 0;
}
```

## Using `this` Pointer

You can use the `this` pointer to distinguish between method arguments and member variables when they have the same name:

```cpp
class Student {
private:
    string name;
    int age;

public:
    // Using 'this' pointer
    void setName(string name) {
        this->name = name;  // this->name is member variable
                            // name is the parameter
    }

    void setAge(int age) {
        this->age = age;
    }

    string getName() const {
        return name;
    }

    int getAge() const {
        return age;
    }
};
```

## Benefits of Getter/Setter Methods

1. **Encapsulation**: Hide internal implementation details
2. **Validation**: Check if values are valid before setting
3. **Control**: Decide what can be read, written, or both
4. **Flexibility**: Can change internal implementation without affecting code that uses the class
5. **Security**: Prevent direct access to sensitive data

## Read-Only Properties

You can create read-only properties by only providing a getter:

```cpp
class BankAccount {
private:
    double balance;
    string accountNumber;

public:
    BankAccount(string accNum, double initialBalance) {
        accountNumber = accNum;
        balance = initialBalance;
    }

    // Read-only: only getter, no setter
    string getAccountNumber() const {
        return accountNumber;
    }

    double getBalance() const {
        return balance;
    }

    // Only controlled way to modify balance
    void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }
};
```

## Write-Only Properties

You can create write-only properties by only providing a setter:

```cpp
class User {
private:
    string password;

public:
    // Write-only: only setter, no getter
    void setPassword(string pwd) {
        // Hash the password before storing
        password = hashFunction(pwd);
    }

    bool verifyPassword(string pwd) {
        return hashFunction(pwd) == password;
    }
};
```

## Best Practices

1. **Make data members private**: This enforces encapsulation
2. **Use meaningful names**: `getName()` is better than `get()`
3. **Validate in setters**: Check if the value makes sense
4. **Mark getters as const**: Show they don't modify the object
5. Don't create getters/setters for all variables - only when external access is genuinely needed
6. **Consider member functions**: Instead of get/set, sometimes a specific action function is better (e.g., `deposit()` instead of `setBalance()`)

## Important Note

Unlike languages like C# or Python, C++ doesn't have native property syntax, so programmers must define accessor and mutator methods manually. However, some compilers offer vendor-specific extensions for property-like behavior.

## Summary

- **Private variables** protect your data from invalid access
- **Getter methods** allow controlled reading of data
- **Setter methods** allow controlled modification with validation
- This pattern is a fundamental part of **encapsulation** in OOP
- Properties help maintain data integrity and provide a clear interface to your class
