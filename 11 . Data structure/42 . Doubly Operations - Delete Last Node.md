---
DATE: 2025-11-03T23:26:00
DONE: true
---


# Operations - Delete Last Node (Doubly Linked List)

## Overview

Deleting the last node (tail) from a doubly linked list requires traversing the list to find the last node, then updating the second-to-last node's `next` pointer to NULL. Unlike deleting the first node which is O(1), this operation requires traversal making it O(n). However, the doubly linked structure makes it easier than in a singly linked list since we have access to the `prev` pointer.

## Visual Example

### Before Deletion
```
NULL <--> [1] <--> [2] <--> [3] <--> NULL
                             ↑
                        (Delete this)
```

### After Deletion
```
NULL <--> [1] <--> [2] <--> NULL
```

## Algorithm Steps

To delete the last node from a doubly linked list:

1. **Check if list is empty**: If head is NULL, return immediately
2. **Check if single node**: If there's only one node, delete it and set head to NULL
3. **Traverse to second-to-last node**: Move through the list until you reach the node before the last one
4. **Store reference to last node**: Keep a pointer to the node we're about to delete
5. **Update next pointer**: Set the second-to-last node's `next` pointer to NULL
6. **Free memory**: Delete the last node

## Implementation

```cpp
void DeleteLastNode(Node*& head) {
    
    // Step 1: Check if list is empty
    if (head == NULL) {
        return;
    }
    
    // Step 2: Check if list has only one node
    if (head->next == NULL) {
        delete head;
        head = NULL;
        return;
    }
    
    // Step 3: Traverse to second-to-last node
    Node* current = head;
    while (current->next->next != NULL) {
        current = current->next;
    }
    
    // Step 4: Store reference to last node
    Node* temp = current->next;
    
    // Step 5: Update next pointer to NULL
    current->next = NULL;
    
    // Step 6: Delete last node
    delete temp;
}
```

## Detailed Explanation

### Step-by-Step Process

#### Initial State
```
head → [1] <--> [2] <--> [3] <--> NULL
```

#### Traversal Process
```
Step 1: current at [1]
        current->next->next = [3] (not NULL, continue)

Step 2: current at [2]
        current->next->next = NULL (stop here!)
        
head → [1] <--> [2] <--> [3] <--> NULL
                 ↑        ↑
              current    temp
```

#### Update and Delete
```
Before: [2] <--> [3] <--> NULL
         ↑        ↑
      current   temp

After:  [2] <--> NULL
         ↑
      current
```

## Edge Cases

### Case 1: Single Node List
```
Before: NULL <--> [1] <--> NULL
                   ↑
                 head

After:  NULL
         ↑
       head
```
- Special handling needed
- Delete the node and set head to NULL

### Case 2: Two Node List
```
Before: NULL <--> [1] <--> [2] <--> NULL
                   ↑        ↑
                 head     delete

After:  NULL <--> [1] <--> NULL
                   ↑
                 head
```
- Current stops at first node
- Delete second node

### Case 3: Multiple Node List
```
Before: NULL <--> [1] <--> [2] <--> [3] <--> NULL
                                     ↑
                                  delete

After:  NULL <--> [1] <--> [2] <--> NULL
```
- Traverse to second-to-last node
- Update its next pointer to NULL

### Case 4: Empty List
```
Before: NULL
         ↑
       head

After:  NULL
         ↑
       head
```
- Function returns immediately
- Nothing to delete

## Complete Example

```cpp
int main()
{
    Node* head = NULL;

    // Create list: 1 <--> 2 <--> 3 <--> 4 <--> 5
    InsertAtBeginning(head, 5);
    InsertAtBeginning(head, 4);
    InsertAtBeginning(head, 3);
    InsertAtBeginning(head, 2);
    InsertAtBeginning(head, 1);

    cout << "\nLinked List Content:\n";
    PrintList(head);
    // Output: NULL <--> 1 <--> 2 <--> 3 <--> 4 <--> 5 <--> NULL

    // Delete last node
    DeleteLastNode(head);
    
    cout << "\nLinked List Content after delete last node:\n";
    PrintList(head);
    // Output: NULL <--> 1 <--> 2 <--> 3 <--> 4 <--> NULL
    
    return 0;
}
```

## Multiple Deletions

You can call `DeleteLastNode` multiple times to remove nodes from the end:

```cpp
DeleteLastNode(head); // Removes 5
// List: NULL <--> 1 <--> 2 <--> 3 <--> 4 <--> NULL

DeleteLastNode(head); // Removes 4
// List: NULL <--> 1 <--> 2 <--> 3 <--> NULL

DeleteLastNode(head); // Removes 3
// List: NULL <--> 1 <--> 2 <--> NULL
```

## Understanding the While Loop

The key to this function is the while loop condition:

```cpp
while (current->next->next != NULL)
```

### Why `current->next->next`?

```
[1] <--> [2] <--> [3] <--> NULL
 ↑        ↑        ↑
current  next   next->next
```

- We want `current` to stop at the **second-to-last** node
- When `current->next->next` is NULL, `current->next` is the last node
- This allows us to update `current->next` to NULL

### What if we used `current->next != NULL`?

```cpp
// ❌ WRONG
while (current->next != NULL) {
    current = current->next;
}
// Current would stop at the LAST node
// We couldn't access the second-to-last node to update it!
```

## Key Points to Remember

1. **Empty list check**: Always verify head is not NULL before proceeding
2. **Single node special case**: Handle this separately as there's no second-to-last node
3. **Traversal condition**: Use `current->next->next != NULL` to stop at second-to-last node
4. **Temporary pointer**: Store the last node before deleting it
5. **Update next pointer**: Set second-to-last node's next to NULL
6. **Memory management**: Always delete the last node to prevent memory leaks

## Alternative Implementation Using prev Pointer

With a doubly linked list, we could also traverse from the end if we had a tail pointer:

```cpp
void DeleteLastNode(Node*& head) {
    if (head == NULL) return;
    
    if (head->next == NULL) {
        delete head;
        head = NULL;
        return;
    }
    
    // If we had a tail pointer, we could do:
    // Node* temp = tail;
    // tail = tail->prev;
    // tail->next = NULL;
    // delete temp;
    
    // But without tail, we traverse from head
    Node* current = head;
    while (current->next->next != NULL) {
        current = current->next;
    }
    
    Node* temp = current->next;
    current->next = NULL;
    delete temp;
}
```

## Time Complexity

- **O(n)** - Linear time where n is the number of nodes
- Must traverse the entire list to reach the second-to-last node
- This is the main disadvantage compared to deleting the first node

## Space Complexity

- **O(1)** - Constant space
- Only uses a few temporary pointers regardless of list size

## Optimization with Tail Pointer

If the doubly linked list maintains a tail pointer:

```cpp
class DoublyLinkedList {
    Node* head;
    Node* tail;  // Maintain tail pointer
    
    void DeleteLastNode() {
        if (tail == NULL) return;
        
        if (head == tail) {  // Single node
            delete head;
            head = tail = NULL;
            return;
        }
        
        Node* temp = tail;
        tail = tail->prev;
        tail->next = NULL;
        delete temp;
    }
};
```

**Time Complexity with tail pointer: O(1)** ✨

## Use Cases

This operation is commonly used in:

1. **Stack Implementation**: Pop operation (when stack grows from the end)
2. **Undo functionality**: Remove the most recent action
3. **Browser history**: Remove forward history when navigating
4. **Task management**: Remove completed tasks from the end
5. **Playlist management**: Remove the last song

## Comparison with Other Delete Operations

| Operation | Need Traversal? | Time Complexity | Efficiency |
|-----------|----------------|-----------------|------------|
| Delete First Node | No | O(1) | ⭐⭐⭐ Very Fast |
| Delete Last Node | Yes | O(n) | ⭐ Slower |
| Delete Last (with tail) | No | O(1) | ⭐⭐⭐ Very Fast |
| Delete Specific Node | Maybe | O(n) | ⭐ Slower |

## Common Mistakes to Avoid

1. ❌ **Not handling single node case**
   ```cpp
   // Will crash with single node
   while (current->next->next != NULL) // next is NULL!
   ```

2. ❌ **Wrong loop condition**
   ```cpp
   while (current->next != NULL) // Stops at last, not second-to-last!
   ```

3. ❌ **Not checking for empty list**
   ```cpp
   // Will crash if head is NULL
   Node* current = head;
   while (current->next->next != NULL)
   ```

4. ❌ **Forgetting to delete the node**
   ```cpp
   current->next = NULL;  // Memory leak! Node still exists
   ```

5. ❌ **Not storing reference before updating**
   ```cpp
   current->next = NULL;  // Lost access to last node!
   // delete current->next; // Can't access it anymore
   ```

## Correct Error Handling

```cpp
void DeleteLastNode(Node*& head) {
    // ✅ Check empty list
    if (head == NULL) {
        cout << "List is empty!\n";
        return;
    }
    
    // ✅ Handle single node
    if (head->next == NULL) {
        delete head;
        head = NULL;
        return;
    }
    
    // ✅ Safe traversal
    Node* current = head;
    while (current->next->next != NULL) {
        current = current->next;
    }
    
    // ✅ Store before deleting
    Node* temp = current->next;
    current->next = NULL;
    delete temp;
}
```

## Advantages of Doubly Linked List

While this operation doesn't directly benefit from the `prev` pointer (since we traverse forward), the doubly linked structure offers:

1. **Easier reversal**: Can traverse backwards
2. **Efficient with tail pointer**: O(1) deletion when tail is maintained
3. **Bidirectional access**: Can access previous node directly
4. **Better for certain algorithms**: Like LRU cache implementation

## Summary

Deleting the last node from a doubly linked list requires:
- **Traversing** to the second-to-last node using `while (current->next->next != NULL)`
- **Special handling** for empty lists and single-node lists
- **Updating** the second-to-last node's next pointer to NULL
- **Deleting** the last node to free memory

This is an **O(n) operation** unless a tail pointer is maintained, making it less efficient than deleting the first node. However, it's essential for many applications like stacks, undo functionality, and playlist management.
