---
DATE: 2025-11-03T23:27:00
DONE: true
---


# Insert at End - Doubly Linked List

## Overview
The **Insert at End** operation adds a new node to the end of a doubly linked list. This means the new node becomes the last element in the list.

## Visual Representation

**Before Insertion:**
```
NULL <--> 1 <--> 2 <--> 500 <--> NULL
Head                           Tail
```

**After Inserting 600 at End:**
```
NULL <--> 1 <--> 2 <--> 500 <--> 600 <--> NULL
Head                                    Tail
```

## How It Works

### Steps to Insert at End:

1. **Create a new node** with the desired value
2. **Set the new node's next pointer to NULL** (since it will be the last node)
3. **Handle two cases:**
   - **Empty List**: If the list is empty (head is NULL)
     - Set the new node's prev pointer to NULL
     - Make the new node the head
   - **Non-Empty List**: If the list has nodes
     - Traverse to the last node
     - Set the last node's next pointer to the new node
     - Set the new node's prev pointer to the last node

## Code Implementation

```cpp
void InsertAtEnd(Node* head, int value) {
    
    // Step 1: Create a new node with the desired value
    Node* newNode = new Node();
    newNode->value = value;
    newNode->next = NULL;
    
    // Step 2: Check if the list is empty
    if (head == NULL) {
        newNode->prev = NULL;
        head = newNode;
    }
    // Step 3: List is not empty
    else {
        // Traverse to the last node
        Node* current = head;
        while (current->next != NULL) {
            current = current->next;
        }
        // Link the last node to the new node
        current->next = newNode;
        newNode->prev = current;
    }
}
```

## Step-by-Step Example

Let's insert value `600` at the end of: `NULL <--> 1 <--> 2 <--> 500 <--> NULL`

### Step 1: Create New Node
```
newNode: [value: 600, next: NULL, prev: ?]
```

### Step 2: List is Not Empty
Since head is not NULL, we go to the else block.

### Step 3: Traverse to Last Node
```
Start: current â†’ 1
Move:  current â†’ 2
Move:  current â†’ 500 (current->next is NULL, so stop)
```

### Step 4: Link the Nodes
```cpp
current->next = newNode;  // 500's next now points to 600
newNode->prev = current;  // 600's prev now points to 500
```

### Final Result:
```
NULL <--> 1 <--> 2 <--> 500 <--> 600 <--> NULL
```

## Time Complexity
- **O(n)** - where n is the number of nodes in the list
- We must traverse the entire list to find the last node

## Space Complexity
- **O(1)** - we only create one new node regardless of list size

## Important Notes

âš ï¸ **Common Mistakes to Avoid:**
1. Forgetting to set `newNode->next = NULL`
2. Not handling the empty list case
3. Not updating the prev pointer of the new node
4. Not checking if `current->next` is NULL before traversing

âœ… **Key Points:**
- The new node always has `next = NULL` (it's the last node)
- Must traverse the entire list to find the last node
- Both forward (next) and backward (prev) links must be updated
- Handle empty list as a special case

## Comparison with Other Operations

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| Insert at Beginning | O(1) | Direct access to head |
| Insert at End | O(n) | Must traverse entire list |
| Insert After | O(1) | If node reference is given |

## Optimization Tip
ðŸ’¡ To make Insert at End **O(1)**, maintain a **tail pointer** that always points to the last node. This eliminates the need to traverse the list.

```cpp
// With tail pointer
void InsertAtEnd(Node*& head, Node*& tail, int value) {
    Node* newNode = new Node();
    newNode->value = value;
    newNode->next = NULL;
    
    if (head == NULL) {
        newNode->prev = NULL;
        head = tail = newNode;
    } else {
        tail->next = newNode;
        newNode->prev = tail;
        tail = newNode;
    }
}
```
