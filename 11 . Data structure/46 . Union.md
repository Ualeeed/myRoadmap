---
DATE: 2025-11-03T23:25:00
DONE: true
---


# Union

## Overview
A **Union** is a special user-defined data type in C++ that allows you to store different data types in the **same memory location**. Unlike structures where each member gets its own memory space, all members of a union share the same memory space.

## Simple Analogy
Think of a union like a **single parking spot** that can hold different types of vehicles at different times:
- Sometimes it holds a car
- Sometimes it holds a motorcycle
- Sometimes it holds a bicycle

But it can only hold **ONE vehicle at a time**, not all three simultaneously. The parking spot (memory) is shared among all possibilities.

## Key Concept: Shared Memory

### Structure (struct) - Separate Memory
```
struct MyStruct {
    int a;      // 4 bytes
    float b;    // 4 bytes
    char c;     // 1 byte
}
Total Size: 9 bytes (each member has its own space)

Memory Layout:
[int a][float b][char c]
```

### Union - Shared Memory
```
union MyUnion {
    int a;      // 4 bytes
    float b;    // 4 bytes
    char c;     // 1 byte
}
Total Size: 4 bytes (all members share the same space)

Memory Layout:
[shared space - 4 bytes]
(can hold int OR float OR char, but only ONE at a time)
```

## Basic Example

```cpp
union MyUnion {
    int intValue;
    float floatValue;
    char charValue;
};

MyUnion data;

// Using as int
data.intValue = 10;
cout << data.intValue;  // Output: 10

// Now using as float (overwrites the int!)
data.floatValue = 3.14;
cout << data.floatValue;  // Output: 3.14
cout << data.intValue;    // Undefined! (corrupted data)
```

## Important Rule: Size of Union

**The size of a union is determined by its largest member.**

```cpp
union Example {
    char c;      // 1 byte
    int i;       // 4 bytes
    double d;    // 8 bytes
}

sizeof(Example) = 8 bytes (size of double, the largest member)
```

## Why Use Unions?

### Primary Reason: **Memory Efficiency** üíæ

When you know that only one member will be used at a time, unions save memory:

```cpp
// Without Union - Uses 9 bytes
struct Data {
    int option1;    // 4 bytes
    float option2;  // 4 bytes
    char option3;   // 1 byte
}

// With Union - Uses only 4 bytes
union Data {
    int option1;    // 4 bytes
    float option2;  // 4 bytes
    char option3;   // 1 byte
}

// Savings: 9 - 4 = 5 bytes per instance!
```

## Real-World Use Cases

### 1. **Network Packet Parsing**
```cpp
union IPAddress {
    unsigned int fullAddress;  // View as complete 32-bit number
    unsigned char bytes[4];    // View as 4 individual bytes
}

// Can access same data in different formats
```

### 2. **Type Conversion**
```cpp
union FloatInt {
    float f;
    int i;
}

// Convert between float bits and int representation
```

### 3. **Variant Data Types**
```cpp
union Value {
    int intVal;
    float floatVal;
    char stringVal[20];
}

// Store different types of values in same space
```

### 4. **Embedded Systems**
- Limited memory environments
- Hardware register access
- Memory-mapped I/O

## Visual Example: Memory Sharing

```
Union Declaration:
union Number {
    int i;
    float f;
    char c;
}

Memory View:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Shared 4 Bytes    ‚îÇ  ‚Üê All members use THIS space
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

When you write:
num.i = 100;
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     100 (int)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Then you write:
num.f = 3.14;
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    3.14 (float)     ‚îÇ  ‚Üê OVERWRITES the int value!
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Previous int value is GONE!
```

## Important Warnings ‚ö†Ô∏è

### 1. **Data Corruption Risk**
```cpp
union Data {
    int x;
    float y;
}

Data d;
d.x = 10;
d.y = 3.14;  // OVERWRITES x!
cout << d.x;  // UNDEFINED BEHAVIOR! (corrupted data)
```

### 2. **Only One Active Member**
- You can only safely read the member that was **last written**
- Reading other members gives undefined/garbage values

### 3. **No Initialization of Multiple Members**
```cpp
union Bad {
    int a = 5;     // OK
    float b = 3.14; // ERROR! Can't initialize multiple members
}
```

### 4. **Type Safety Issues**
- Compiler doesn't track which member is active
- You must manually remember what was last stored
- Easy to make mistakes!

## Best Practices

‚úÖ **Track Active Member**: Use an enum or flag to remember which member is valid
```cpp
enum DataType { INT_TYPE, FLOAT_TYPE, CHAR_TYPE };

struct SafeUnion {
    DataType activeType;  // Track which is valid
    union {
        int intVal;
        float floatVal;
        char charVal;
    } data;
}
```

‚úÖ **Use Only When Necessary**: Prefer structs unless memory is critical
‚úÖ **Document Usage**: Clearly comment which member should be used when
‚úÖ **Consider Alternatives**: Modern C++ has `std::variant` (safer option)

## Union vs Structure Comparison

| Feature | Structure | Union |
|---------|-----------|-------|
| **Memory** | Each member has own space | All members share space |
| **Size** | Sum of all members | Size of largest member |
| **Access** | All members accessible | Only one valid at a time |
| **Use Case** | Store multiple values together | Store alternative values |
| **Safety** | Safer (no overlap) | Risky (data corruption) |

## Modern Alternative: std::variant (C++17)

```cpp
#include <variant>

std::variant<int, float, char> safeUnion;

safeUnion = 10;           // Store int
safeUnion = 3.14f;        // Store float
safeUnion = 'A';          // Store char

// Type-safe access
if (std::holds_alternative<int>(safeUnion)) {
    cout << std::get<int>(safeUnion);
}
```

**Advantages of std::variant:**
- Type-safe
- Tracks active type automatically
- Prevents undefined behavior
- More modern C++ approach

## Common Mistakes to Avoid

‚ùå **Mistake 1**: Reading wrong member
```cpp
union U { int i; float f; };
U u;
u.i = 10;
cout << u.f;  // WRONG! Undefined behavior
```

‚ùå **Mistake 2**: Assuming all members are valid
```cpp
// Only the LAST assigned member is valid!
```

‚ùå **Mistake 3**: Using complex types without care
```cpp
union Bad {
    std::string s;  // Dangerous! Has constructor/destructor
    int i;
}
```

## When to Use Unions

### ‚úÖ Good Use Cases:
- Embedded systems with limited memory
- Low-level hardware programming
- Network protocol handling
- Type punning (with caution)
- Legacy code compatibility

### ‚ùå Avoid When:
- Type safety is important
- Working with complex objects
- In modern C++ (use `std::variant` instead)
- When debugging is critical
- Team is unfamiliar with unions

## Simple Code Example

```cpp
#include <iostream>
using namespace std;

union Data {
    int intValue;
    float floatValue;
    char charValue;
};

int main() {
    Data data;
    
    // Store and retrieve int
    data.intValue = 42;
    cout << "Int: " << data.intValue << endl;  // Output: 42
    
    // Store float (overwrites int!)
    data.floatValue = 3.14;
    cout << "Float: " << data.floatValue << endl;  // Output: 3.14
    cout << "Int now: " << data.intValue << endl;  // Garbage value!
    
    // Store char (overwrites float!)
    data.charValue = 'A';
    cout << "Char: " << data.charValue << endl;   // Output: A
    
    cout << "Size of union: " << sizeof(Data) << endl;  // 4 bytes
    
    return 0;
}
```

## Summary

A **Union** is a memory-saving data type where all members share the same memory location. Think of it as a shared container that can hold different types of data, but only **one at a time**. The size of a union equals the size of its largest member. While unions can save memory, they require careful usage to avoid data corruption and undefined behavior.

**Key Takeaway**: Unions trade type safety for memory efficiency. Use them only when necessary and consider modern alternatives like `std::variant` for safer code!

---

**Related Topics:**
- [[Structures (struct)]]
- [[Enums]]
- [[Memory Management]]
- [[std::variant]]
- [[Type Safety]]
