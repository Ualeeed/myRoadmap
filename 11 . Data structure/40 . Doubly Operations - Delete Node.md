---
DATE: 2025-11-03T23:27:00
DONE: true
---


# Operations - Delete Node (Doubly Linked List)

## Overview
Deleting a node from a doubly linked list involves updating both the **next** and **prev** pointers of the neighboring nodes to bypass the node being deleted. Since each node has connections in both directions, we need to handle both forward and backward links.

## Visual Example

### Before Deletion
```
NULL <--> [1] <--> [2] <--> [3] <--> NULL
              ↑
         Delete this node
```

### After Deletion
```
NULL <--> [1] <--> [3] <--> NULL
```

## Algorithm Steps

To delete a node from a doubly linked list:

1. **Check for special cases**: If the list is empty or the node to delete is NULL, return immediately
2. **Update head if needed**: If the node to delete is the head, update head to point to the next node
3. **Update next pointer**: If there's a node after the one being deleted, update its `prev` pointer to skip the deleted node
4. **Update previous pointer**: If there's a node before the one being deleted, update its `next` pointer to skip the deleted node
5. **Free memory**: Delete the node to free up memory

## Implementation

```cpp
void DeleteNode(Node*& head, Node*& NodeToDelete) {
    
    // Step 1: Check if list is empty or node is NULL
    if (head == NULL || NodeToDelete == NULL) {
        return;
    }
    
    // Step 2: If node to delete is the head
    if (head == NodeToDelete) {
        head = NodeToDelete->next;
    }
    
    // Step 3: Update the next node's prev pointer
    if (NodeToDelete->next != NULL) {
        NodeToDelete->next->prev = NodeToDelete->prev;
    }
    
    // Step 4: Update the previous node's next pointer
    if (NodeToDelete->prev != NULL) {
        NodeToDelete->prev->next = NodeToDelete->next;
    }
    
    // Step 5: Delete the node
    delete NodeToDelete;
}
```

## Detailed Explanation

### Case 1: Deleting the Head Node
```
Before: NULL <--> [2] <--> [3] <--> [4] <--> NULL
                   ↑
                 head

After:  NULL <--> [3] <--> [4] <--> NULL
                   ↑
                 head
```
- Update `head` to point to the second node
- Update the new head's `prev` pointer to NULL

### Case 2: Deleting a Middle Node
```
Before: NULL <--> [1] <--> [2] <--> [3] <--> NULL
                            ↑
                        Delete this

After:  NULL <--> [1] <--> [3] <--> NULL
```
- Node 1's `next` pointer now points to Node 3
- Node 3's `prev` pointer now points to Node 1
- Node 2 is removed from the chain

### Case 3: Deleting the Last Node
```
Before: NULL <--> [1] <--> [2] <--> [3] <--> NULL
                                     ↑
                                 Delete this

After:  NULL <--> [1] <--> [2] <--> NULL
```
- Node 2's `next` pointer becomes NULL
- Node 3 is deleted

## Complete Example

```cpp
int main()
{
    Node* head = NULL;

    // Create list: 1 <--> 2 <--> 3 <--> 4 <--> 5
    InsertAtBeginning(head, 5);
    InsertAtBeginning(head, 4);
    InsertAtBeginning(head, 3);
    InsertAtBeginning(head, 2);
    InsertAtBeginning(head, 1);

    cout << "\nLinked List Content:\n";
    PrintList(head);
    // Output: NULL <--> 1 <--> 2 <--> 3 <--> 4 <--> 5 <--> NULL

    // Find and delete node with value 4
    Node* N1 = Find(head, 4);
    DeleteNode(head, N1);
   
    cout << "\nLinked List Content after delete:\n";
    PrintList(head);
    // Output: NULL <--> 1 <--> 2 <--> 3 <--> 5 <--> NULL
    
    return 0;
}
```

## Key Points to Remember

1. **Two-way connections**: Always update both `next` and `prev` pointers when deleting
2. **NULL checks**: Always check if pointers are NULL before dereferencing them
3. **Special cases**: Handle deletion of head, middle nodes, and tail nodes properly
4. **Memory management**: Always free the memory by deleting the node
5. **Reference parameters**: Use `Node*&` to modify the head pointer if needed

## Time Complexity

- **O(1)** - Constant time if you already have a pointer to the node to delete
- **O(n)** - Linear time if you need to search for the node first (where n is the number of nodes)

## Space Complexity

- **O(1)** - No additional space is needed beyond a few pointers

## Advantages over Singly Linked List

In a doubly linked list, deletion is easier because:
- You can access the previous node directly through the `prev` pointer
- You don't need to traverse from the head to find the previous node
- Deletion operations are more efficient (O(1) vs O(n) when you have the node pointer)

## Common Mistakes to Avoid

1. ❌ Forgetting to update the `prev` pointer of the next node
2. ❌ Not checking if the node to delete is the head
3. ❌ Not checking for NULL pointers before accessing them
4. ❌ Forgetting to delete the node (memory leak)
5. ❌ Not updating both directions of the links

## Summary

Deleting a node from a doubly linked list requires careful management of both forward (`next`) and backward (`prev`) links. The operation is straightforward but requires handling several edge cases to ensure the list maintains its integrity after deletion.
