



```cpp
#include <iostream>
using namespace std;

// Create a node
class Node 
{
public:
    int value;
    Node* next;
};

void InsertAtBeginning(Node* &head, int value) 
{
    
    // Allocate memory to a node
    Node * new_node = new Node();

    // insert the data
    new_node->value = value;
    new_node->next = head;

    // Move head to new node
    head = new_node;
   
}

// Print the linked list
void PrintList( Node* head) 

{
    while (head != NULL) {
        cout << head->value << " ";
        head = head->next;
    }
}

int main() 
{
    Node * head = NULL;

    InsertAtBeginning(head, 1);
    InsertAtBeginning(head, 2);
    InsertAtBeginning(head, 3);
    InsertAtBeginning(head, 4);
    InsertAtBeginning(head, 5);

    PrintList(head);

    system("pause>0");

}
```


---

## ðŸ“š Easy Explanation: Insert At Beginning Operation

### What Does "Insert At Beginning" Mean?

Inserting at the beginning means adding a new node **before** the current first node (head) of the linked list. It's like adding a new person at the front of a line!

### Why Insert At Beginning?

âœ… **Super Fast!** - Takes only O(1) time (constant time)
âœ… **No Traversal** - Don't need to walk through the entire list
âœ… **Simple Logic** - Just 3 steps!

---

## ðŸŽ¯ The Algorithm - 3 Simple Steps

```mermaid
graph TD
    A[Step 1: Create New Node] --> B[Step 2: Point new_node->next to current head]
    B --> C[Step 3: Update head to point to new_node]
    
    style A fill:#c8e6c9
    style B fill:#fff9c4
    style C fill:#bbdefb
```

---

## ðŸ“Š Visual Step-by-Step Example

Let's trace what happens when we run the main function:

### Initial State
```
head = NULL
```

**Visual:**
```
head â†’ NULL
```

---

### After `InsertAtBeginning(head, 1)`

**Step 1:** Create new node with value 1
```
new_node: [1 | ?]
head â†’ NULL
```

**Step 2:** Point new_node->next to current head (NULL)
```
new_node: [1 | NULL]
head â†’ NULL
```

**Step 3:** Update head to new_node
```
head â†’ [1 | NULL]
```

---

### After `InsertAtBeginning(head, 2)`

**Before:**
```
head â†’ [1 | NULL]
```

**Step 1:** Create new node with value 2
```
new_node: [2 | ?]
head â†’ [1 | NULL]
```

**Step 2:** Point new_node->next to current head
```
new_node: [2 | â†’] ----â†’ [1 | NULL]
head â†’ [1 | NULL]
```

**Step 3:** Update head to new_node
```
head â†’ [2 | â†’] â†’ [1 | NULL]
```

---

### Complete Sequence Visualization

```mermaid
graph LR
    subgraph "After Insert 1"
    A1[head] --> B1[1  NULL]
    end
    
    subgraph "After Insert 2"
    A2[head] --> B2[2  â†’] --> C2[1  NULL]
    end
    
    subgraph "After Insert 3"
    A3[head] --> B3[3  â†’] --> C3[2  â†’] --> D3[1  NULL]
    end
    
    subgraph "After Insert 4"
    A4[head] --> B4[4  â†’] --> C4[3  â†’] --> D4[2  â†’] --> E4[1  NULL]
    end
    
    subgraph "After Insert 5"
    A5[head] --> B5[5  â†’] --> C5[4 â†’] --> D5[3  â†’] --> E5[2  â†’] --> F5[1  NULL]
    end
    
    style B1 fill:#ffcdd2
    style B2 fill:#f8bbd0
    style B3 fill:#e1bee7
    style B4 fill:#d1c4e9
    style B5 fill:#c5cae9
```

---

## ðŸ” Code Breakdown

### The Function Signature
```cpp
void InsertAtBeginning(Node* &head, int value)
```

**Important:** Notice the `&` in `Node* &head`
- This is a **reference parameter**
- Allows us to modify the actual head pointer
- Without `&`, changes wouldn't persist outside the function

---

### Inside the Function

#### Step 1ï¸âƒ£: Create New Node
```cpp
Node* new_node = new Node();
```
Allocates memory for a new node on the heap.

#### Step 2ï¸âƒ£: Set Value and Link
```cpp
new_node->value = value;        // Store the data
new_node->next = head;          // Point to current first node
```

**Visual:**
```
new_node: [value | â†’] â†’ [old head]
```

#### Step 3ï¸âƒ£: Update Head
```cpp
head = new_node;
```
Now the new node becomes the first node!

**Visual:**
```
head â†’ [new_node] â†’ [old head] â†’ ...
```

---

## ðŸŽ¬ Animation of Insert Process

```mermaid
sequenceDiagram
    participant H as head
    participant N as new_node
    participant L as Linked List
    
    Note over H L: Initial: head â†’ [1  NULL]
    
    N->>N: Create new_node with value 2
    Note over N: new_node: [2  ?]
    
    N->>L: new_node->next = head
    Note over N,L: new_node: [2  â†’] points to [1  NULL]
    
    H->>N: head = new_node
    Note over H N L: head â†’ [2  â†’] â†’ [1  NULL]
```

---

## ðŸ“‹ Execution Trace Table

| Step | Function Call | List State | Notes |
|------|--------------|------------|-------|
| 0 | Initial | `NULL` | Empty list |
| 1 | `InsertAtBeginning(head, 1)` | `1 â†’ NULL` | First node |
| 2 | `InsertAtBeginning(head, 2)` | `2 â†’ 1 â†’ NULL` | 2 is now first |
| 3 | `InsertAtBeginning(head, 3)` | `3 â†’ 2 â†’ 1 â†’ NULL` | 3 is now first |
| 4 | `InsertAtBeginning(head, 4)` | `4 â†’ 3 â†’ 2 â†’ 1 â†’ NULL` | 4 is now first |
| 5 | `InsertAtBeginning(head, 5)` | `5 â†’ 4 â†’ 3 â†’ 2 â†’ 1 â†’ NULL` | 5 is now first |

### Final Output
```
5 4 3 2 1
```

**Notice:** The order is **reversed**! Last inserted = First in list

---

## ðŸŽ¯ Real-World Analogies

### 1. **Stack of Plates** ðŸ½ï¸
- Adding a new plate on top of the stack
- The newest plate is always on top (beginning)
- You always add/remove from the top

### 2. **Line at a Store** ðŸª
- Someone cuts to the front of the line
- They become the new first person
- Everyone else shifts back one position

### 3. **Browser History** ðŸŒ
- Each new page you visit goes to the front
- The most recent page is always first
- Older pages are pushed back

---

## âš¡ Time Complexity Analysis

| Operation | Time Complexity | Why? |
|-----------|----------------|------|
| **Insert at Beginning** | O(1) | Only 3 operations, no loops |
| **Traversal/Print** | O(n) | Must visit each node |
| **Space** | O(1) | Only one new node created |

**O(1) means:** No matter how long the list is (10 nodes or 10,000 nodes), inserting at the beginning takes the same amount of time!

---

## ðŸ”‘ Key Points to Remember

1. **Reference Parameter (`&`)**: Essential for modifying the actual head pointer
2. **Three Steps**: Create â†’ Link â†’ Update head
3. **Order**: New elements go to the **front**, creating reverse order
4. **Efficiency**: Fastest insertion method for linked lists (O(1))
5. **No Traversal**: We never need to walk through the list

---

## â“ Common Questions

**Q: Why use `Node* &head` instead of `Node* head`?**
A: Without `&`, we'd only modify a local copy. The original head wouldn't change!

**Q: What if head is NULL?**
A: No problem! `new_node->next = NULL` and `head = new_node` works perfectly.

**Q: Why is the output 5 4 3 2 1 instead of 1 2 3 4 5?**
A: Because each new number is inserted at the **beginning**, pushing older numbers back.

**Q: Can we make it print 1 2 3 4 5?**
A: Yes! Either insert at the end, or insert in reverse order (5, 4, 3, 2, 1).

---

## ðŸŽ“ Practice Challenge

Try to predict the output:
```cpp
Node* head = NULL;
InsertAtBeginning(head, 10);
InsertAtBeginning(head, 20);
InsertAtBeginning(head, 30);
PrintList(head);
```

<details>
<summary>Click to see answer</summary>

Output: `30 20 10`

Why? 30 was inserted last, so it's at the beginning!
</details>

