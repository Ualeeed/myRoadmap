---
DATE: 2025-10-28T23:18:00
DONE: true
---


#### Recursion

is a programming technique where a function calls itself to solve a problem. It uses the method of dividing the program into sub-tasks and calling it repeatedly to solve complex problems.

A recursive function is a function which calls itself, either directly or indirectly, to address a problem. It must include at least one base case to terminate the recursion and one recursive case where the function invokes itself.

## Key Components

### Base Case
A case where recursion stops or ends after reaching that particular condition. The most important thing about recursion is it should have the base case to terminate the recursion.

### Recursive Case
A case where a function calls itself over again with decremented value until it reaches its base case.

## Basic Syntax

```cpp
void recurse() {
    // Base case
    if (condition) {
        return;
    }
    
    // Recursive case
    recurse(); // Function calls itself
}
```

## How Recursion Works

The function call occurs before returning a value, so the stack frames for each recursive call are placed on top of the existing stack frames in memory. Once the topmost function returns a value, its stack frame is removed, and control is passed back to the function just before it.

## Types of Recursion

### 1. Direct Recursion
Direct recursion occurs when a function calls itself directly.

#### a) Tail Recursion
A form of direct recursion where the recursive call is the last operation in the function. It is used for solving accumulative calculations and list processing problems.

```cpp
int factorial(int n, int result = 1) {
    if (n <= 1) {
        return result;
    } else {
        return factorial(n - 1, n * result); // Tail recursive call
    }
}
```

#### b) Head Recursion
The recursive call is made before any other operation in the function. Processing occurs after the recursive call returns.

```cpp
void printNumbers(int n) {
    if (n > 0) {
        printNumbers(n - 1); // Recursive call first
        cout << n << " ";     // Processing after recursive call
    }
}
```

### 2. Indirect Recursion
When function calls another function and that function calls the calling function. For example: function A calls function B and Function B calls function A.

```cpp
int fa(int n) {
    if(n <= 1) 
        return 1;
    else 
        return n * fb(n - 1);
}

int fb(int n) {
    if(n <= 1) 
        return 1;
    else 
        return n * fa(n - 1);
}
```

## Common Examples

### 1. Factorial Calculation

```cpp
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n > 1) {
        return n * factorial(n - 1);
    } else {
        return 1;
    }
}

int main() {
    int n, result;
    cout << "Enter a non-negative number: ";
    cin >> n;
    result = factorial(n);
    cout << "Factorial of " << n << " = " << result;
    return 0;
}
```

**How it works:**
- `factorial(4)` calls `factorial(3)`
- `factorial(3)` calls `factorial(2)`
- `factorial(2)` calls `factorial(1)`
- `factorial(1)` returns 1 (base case)
- Then it backtracks: 2×1 = 2, then 3×2 = 6, then 4×6 = 24

### 2. Fibonacci Sequence

```cpp
#include <iostream>
using namespace std;

int fibonacci(int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int n = 7;
    cout << "Fibonacci(" << n << ") = " << fibonacci(n);
    return 0;
}
```

## Advantages of Recursion

Programmers can create code that is elegant and concise by using recursion. Here are the main advantages:

1. **Code Simplification**: Makes code shorter and cleaner
2. **Readability**: More intuitive for certain problems
3. **Natural Solution**: Recursive algorithms are often used to traverse trees and graphs, such as depth-first search
4. **Complex Problems**: Complex problems that are challenging or impossible to solve using iterative methods benefit greatly from recursion

## Disadvantages of Recursion

Stack overflow is one of the most common errors associated with recursion which occurs when a function calls itself too many times. Other disadvantages include:

1. **Performance**: Recursive algorithms can be less efficient than iterative algorithms in some cases, particularly if the data structure is large or if the recursion goes too deep
2. **Memory Usage**: Recursive algorithms can use a lot of memory, particularly if the recursion goes too deep or if the data structure is large
3. **Debugging**: More difficult to debug than iterative algorithms
4. **Slower Execution**: Requires more time due to function call overhead

## When to Use Recursion vs Iteration

### Use Recursion When:
- Problems can be divided into similar sub-problems or which have natural recursive patterns such as tree traversal or combinational tasks and manageable depth
- You need clean, readable code
- Working with tree and graph traversals
- Implementing divide-and-conquer algorithms (quicksort, mergesort)
- Solving backtracking problems (mazes, puzzles)

### Use Iteration When:
- Problems require simple looping or simple mathematical computation
- You need better performance and memory efficiency
- Problems require a large number of repetitions, as iteration doesn't risk stack overflow
- Working with simple array/vector traversals

## Common Applications

Tree and Graph Traversal, Mathematical Computations such as factorial and Fibonacci, and Dynamic Programming techniques for solving optimization problems.

## Important Notes

1. **Always define a base case** to prevent infinite recursion
2. **Use if-else statements** to check the base case condition
3. The compiler uses an instruction pointer to keep track of the location to return to after the function execution is complete
4. Be aware of stack memory limitations
5. Consider converting to iteration for better performance in production code



---

