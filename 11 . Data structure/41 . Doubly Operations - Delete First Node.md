---
DONE: true
DATE: 2025-11-03T23:26:00
---


# Operations - Delete First Node (Doubly Linked List)

## Overview
Deleting the first node (head) from a doubly linked list is a special case of node deletion. It requires updating the head pointer to point to the second node and adjusting the `prev` pointer of the new head to NULL. This is one of the most common operations when implementing stack-like behavior with a linked list.

## Visual Example

### Before Deletion
```
NULL <--> [1] <--> [2] <--> [3] <--> NULL
           ↑
         head
      (Delete this)
```

### After Deletion
```
NULL <--> [2] <--> [3] <--> NULL
           ↑
         head
```

## Algorithm Steps

To delete the first node from a doubly linked list:

1. **Check if list is empty**: If head is NULL, there's nothing to delete, so return immediately
2. **Store reference to head**: Keep a temporary pointer to the current head node (for deletion later)
3. **Update head pointer**: Move the head pointer to the next node in the list
4. **Update new head's prev pointer**: If the new head exists, set its `prev` pointer to NULL
5. **Free memory**: Delete the old head node using the temporary pointer

## Implementation

```cpp
void DeleteFirstNode(Node*& head) {
   
    // Step 1: Check if list is empty
    if (head == NULL) {
        return;
    }
    
    // Step 2: Store reference to current head
    Node* temp = head;
    
    // Step 3: Update head to point to next node
    head = head->next;
    
    // Step 4: Update new head's prev pointer to NULL
    if (head != NULL) {
        head->prev = NULL;
    }
    
    // Step 5: Delete the old head node
    delete temp;
}
```

## Detailed Explanation

### Step-by-Step Process

#### Initial State
```
temp = ?
head → [1] <--> [2] <--> [3] <--> NULL
```

#### Step 1: Store Reference
```
temp → [1] <--> [2] <--> [3] <--> NULL
head → [1]
```

#### Step 2: Move Head
```
temp → [1] <--> [2] <--> [3] <--> NULL
head --------→ [2]
```

#### Step 3: Update Prev Pointer
```
temp → [1]   [2] <--> [3] <--> NULL
       ↑      ↑
     Delete  head (prev = NULL)
```

#### Step 4: Delete Old Head
```
NULL <--> [2] <--> [3] <--> NULL
           ↑
         head
```

## Edge Cases

### Case 1: List with One Node
```
Before: NULL <--> [1] <--> NULL
                   ↑
                 head

After:  NULL
         ↑
       head
```
- Head becomes NULL
- The list is now empty

### Case 2: List with Multiple Nodes
```
Before: NULL <--> [1] <--> [2] <--> [3] <--> NULL
                   ↑
                 head

After:  NULL <--> [2] <--> [3] <--> NULL
                   ↑
                 head
```
- Node 2 becomes the new head
- Node 2's prev pointer is set to NULL

### Case 3: Empty List
```
Before: NULL
         ↑
       head

After:  NULL
         ↑
       head
```
- Nothing happens
- Function returns immediately

## Complete Example

```cpp
int main()
{
    Node* head = NULL;

    // Create list: 1 <--> 2 <--> 3 <--> 4 <--> 5
    InsertAtBeginning(head, 5);
    InsertAtBeginning(head, 4);
    InsertAtBeginning(head, 3);
    InsertAtBeginning(head, 2);
    InsertAtBeginning(head, 1);

    cout << "\nLinked List Content:\n";
    PrintList(head);
    // Output: NULL <--> 1 <--> 2 <--> 3 <--> 4 <--> 5 <--> NULL

    // Delete first node
    DeleteFirstNode(head);
   
    cout << "\nLinked List Content after delete:\n";
    PrintList(head);
    // Output: NULL <--> 2 <--> 3 <--> 4 <--> 5 <--> NULL
    
    return 0;
}
```

## Multiple Deletions

You can call `DeleteFirstNode` multiple times to remove nodes from the beginning:

```cpp
DeleteFirstNode(head); // Removes 1
// List: NULL <--> 2 <--> 3 <--> 4 <--> 5 <--> NULL

DeleteFirstNode(head); // Removes 2
// List: NULL <--> 3 <--> 4 <--> 5 <--> NULL

DeleteFirstNode(head); // Removes 3
// List: NULL <--> 4 <--> 5 <--> NULL
```

## Key Points to Remember

1. **Empty list check**: Always verify that head is not NULL before deletion
2. **Temporary pointer**: Store the old head in a temp variable to delete it after updating head
3. **Update head first**: Move head pointer before deleting the old head
4. **NULL check for new head**: Check if the new head exists before setting its prev pointer
5. **Memory management**: Always delete the old node to prevent memory leaks
6. **Reference parameter**: Use `Node*&` to modify the head pointer

## Why Use a Temporary Pointer?

```cpp
// ❌ WRONG - Memory leak!
void DeleteFirstNode(Node*& head) {
    if (head == NULL) return;
    head = head->next;  // Lost reference to old head!
    // Can't delete the old head node now
}

// ✅ CORRECT - Proper cleanup
void DeleteFirstNode(Node*& head) {
    if (head == NULL) return;
    Node* temp = head;    // Save reference
    head = head->next;    // Update head
    delete temp;          // Delete old head
}
```

## Time Complexity

- **O(1)** - Constant time operation
- We only access and modify the first node, regardless of list size
- This makes it very efficient compared to operations that require traversal

## Space Complexity

- **O(1)** - Constant space
- Only one temporary pointer is used

## Use Cases

This operation is commonly used in:

1. **Stack Implementation (LIFO)**: Removing the most recently added element
2. **Queue Implementation**: Dequeue operation removes from the front
3. **Undo functionality**: Removing the most recent action from history
4. **Browser history**: Removing the current page when going back
5. **Task scheduling**: Removing the highest priority task

## Comparison with Other Operations

| Operation | Need to Search? | Time Complexity |
|-----------|----------------|-----------------|
| Delete First Node | No | O(1) |
| Delete Last Node | Yes (traverse) | O(n) |
| Delete Specific Node | Yes (if searching) | O(n) |
| Delete by Value | Yes (search first) | O(n) |

## Common Mistakes to Avoid

1. ❌ **Not checking for empty list**
   ```cpp
   // Will crash if head is NULL
   Node* temp = head;
   head = head->next;
   ```

2. ❌ **Not checking new head before accessing prev**
   ```cpp
   head = head->next;
   head->prev = NULL;  // Crashes if head is now NULL!
   ```

3. ❌ **Forgetting to delete the old node**
   ```cpp
   head = head->next;  // Memory leak!
   ```

4. ❌ **Deleting before updating head**
   ```cpp
   delete head;       // Lost access to the list!
   head = head->next; // Can't access next anymore!
   ```

## Advantages of Doubly Linked List

For this operation, doubly linked lists work the same as singly linked lists since we only need to access the `next` pointer. However, the `prev` pointer must be properly set to NULL for the new head to maintain list integrity.

## Summary

Deleting the first node from a doubly linked list is a straightforward O(1) operation that involves:
- Storing a reference to the current head
- Moving the head pointer to the next node
- Setting the new head's prev pointer to NULL
- Deleting the old head node

This operation is efficient and commonly used in stack and queue implementations, making it an essential operation for data structure management.
