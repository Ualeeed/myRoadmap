# Big O(1) - Constant Time Function

## What is O(1)?

**O(1)** means an algorithm takes the **same amount of time** to execute, no matter how large the input is. It's called "constant time" because the number of operations doesn't change.

Think of it like this: Whether you have a book with 10 pages or 1,000 pages, opening it to read the **last page** always takes the same effort - just flip to the end!

## Key Characteristics

- âš¡ **Always the same speed** - doesn't matter if you have 10 items or 10 million items
- ğŸ¯ **Most efficient** - the fastest Big O notation possible
- ğŸ“Š **Independent of input size** - performance stays constant

## Real-World Example

Imagine you have a list of phone numbers. Getting the **last phone number** in the list is an O(1) operation - you just go directly to the end, whether there are 5 numbers or 5,000 numbers.

## Code Examples

### âœ… Example 1: Perfect O(1)

```c++
char GetLastCharacter(string S1)
{
    return S1[S1.length() - 1];
}
```

**Why is this O(1)?**
- Step 1: Get the length of the string
- Step 2: Subtract 1
- Step 3: Access that position in the array
- Step 4: Return the character

**Total: 4 steps** - and it's ALWAYS 4 steps, no matter if the string is 5 characters or 5 million characters!

### âŒ Example 2: Looks complicated but still O(1)

```cpp
char GetLastCharacter2(string S1)
{
    int n = S1.length() - 1;
    for (int i = 0; i <= n; i++)
    {
        if (i == n)
        {
            return S1[n];
        }
    }
}
```

Even though this has a loop, it still performs the same number of operations regardless of string size for this specific logic.

## How to Calculate O(1)

1. **Count the steps** in your algorithm
2. **Check if the steps change** based on input size
3. If the steps are always the same â†’ **O(1)**

### Formula:
```
Number of Steps = 4 (constant)
Big O = 4 Ã— O(1) = O(1)
```

We remove constant factors (like the 4), so it simplifies to just **O(1)**.

## Common O(1) Operations

- Accessing an array element by index: `array[5]`
- Getting the first or last element of a list
- Inserting at the beginning of a linked list
- Simple arithmetic operations: `a + b`
- Assigning a value to a variable: `x = 10`
- Returning a value: `return x`

## Why O(1) is Amazing

```
Input Size    | Time
------------- | ----
10 items      | âš¡ 1 unit
100 items     | âš¡ 1 unit
1,000 items   | âš¡ 1 unit
1,000,000     | âš¡ 1 unit
```

*No matter how big your data gets, O(1) operations stay lightning fast! ğŸš€

## Remember

> **O(1) = Constant Time = Always Fast = Best Case Scenario**

When designing algorithms, aim for O(1) operations whenever possible!

---
