---
DATE: 2025-10-30T11:09:00
DONE: true
---

**Linear Time Complexity O(n)** means the execution time of an algorithm grows **directly proportional** to the input size. If you double the input, the execution time doubles as well.

---

## ğŸ¯ Key Concept

> **O(n) = Linear Growth**
> 
> As the input size (n) increases, the number of operations increases at the same rate.

### Visual Representation

```
Input Size (n)     Operations
    1         â†’        1
    2         â†’        2
    3         â†’        3
    4         â†’        4
    5         â†’        5
    ...       â†’       ...
    n         â†’        n
```

---

## ğŸ“Š Growth Graph

```
Operations
    |
 10 |                    â—
    |                 â—
  8 |              â—
    |           â—
  6 |        â—
    |     â—
  4 |  â—
    |â—
  2 |
    |________________________
      2  4  6  8  10  (n)
      
Linear Growth: Straight line at 45Â° angle
```

---

## ğŸ’¡ Real-World Example

### Algorithm 1: O(1) - Constant Time âš¡

```c++
char GetLastCharacter(string S1)
{
    return S1[S1.length() - 1];
}
```

**Time Complexity:** O(1)
- **Operations:** Always 2 steps (get length, access index)
- **Speed:** Instant, regardless of string length
- âœ… **Better Performance**

---

### Algorithm 2: O(n) - Linear Time ğŸŒ

```cpp
char GetLastCharacter2(string S1)
{
    int n = S1.length() - 1;
    for (int i = 0; i <= n; i++)
    {
        if (i == n)
        {
            return S1[n];
        }
    }
}
```

**Time Complexity:** O(n)
- **Operations:** Loops through entire string
- **Speed:** Grows with string length
- âŒ **Slower Performance**

---

## ğŸ”¢ Calculating O(n) Complexity

### Step-by-Step Breakdown

```cpp
char GetLastCharacter2(string S1)
{
    int n = S1.length() - 1;        // 1 operation
    
    for (int i = 0; i <= n; i++)    // 1 + n + n operations
    {                                // (initialize, n comparisons, n increments)
        if (i == n)                  // n operations
        {
            return S1[n];            // 2 operations (when condition met)
        }
    }
}
```

### Counting Operations

| Part | Operations |
|------|-----------|
| Outside loop | 4 steps |
| Inside loop (per iteration) | 6 steps |
| **Total** | **6n + 4** |

### Simplification Process

```
Total Steps = 6n + 4

Step 1: Remove constants (the +4)
        6n

Step 2: Remove coefficients (the 6)
        n

Final: O(n)
```

> **Rule:** In Big O notation, we only keep the **dominant term** and remove constants and coefficients.

---

## ğŸ“ˆ Performance Comparison

### O(1) vs O(n)

```
Time
  |
  |                           O(n)
  |                       â—â—â—
  |                   â—â—â—
  |              â—â—â—
  |          â—â—â—
  |      â—â—â—
  |  â—â—â—   
  |â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—  O(1)
  |________________________
    Input Size (n)
```

### Execution Time Example

| Input Size | O(1) Steps | O(n) Steps | Difference |
|-----------|-----------|-----------|-----------|
| 10 | 2 | 64 | 32Ã— slower |
| 100 | 2 | 604 | 302Ã— slower |
| 1000 | 2 | 6004 | 3002Ã— slower |
| 10000 | 2 | 60004 | 30002Ã— slower |

---

## ğŸª Common O(n) Operations

### Examples in Programming

1. **Linear Search**
```cpp
int FindElement(int arr[], int n, int target)
{
    for (int i = 0; i < n; i++)  // O(n)
    {
        if (arr[i] == target)
            return i;
    }
    return -1;
}
```

2. **Printing All Elements**
```cpp
void PrintArray(int arr[], int n)
{
    for (int i = 0; i < n; i++)  // O(n)
    {
        cout << arr[i] << " ";
    }
}
```

3. **Summing Elements**
```cpp
int SumArray(int arr[], int n)
{
    int sum = 0;
    for (int i = 0; i < n; i++)  // O(n)
    {
        sum += arr[i];
    }
    return sum;
}
```

---

## ğŸ§  Memory Aid

Think of O(n) like **reading a book**:
- If the book has 100 pages, you read ~100 pages
- If the book has 500 pages, you read ~500 pages
- **Time grows with the number of pages (n)**

---

## âœ… Key Takeaways

1. **O(n) = Linear relationship** between input size and execution time
2. **Single loop** through data typically indicates O(n)
3. **Always slower** than O(1) for large inputs
4. **Remove constants and coefficients** when calculating Big O
5. **Most common complexity** for basic algorithms


---

*Remember: The goal of analyzing complexity is to choose the most efficient algorithm for your specific use case!* ğŸš€