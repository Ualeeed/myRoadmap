---
DONE: true
DATE: 2025-10-28T11:03:00
---


#### A dynamic array

(also called growable array, resizable array, or vector) is a variable-size array that can grow or shrink during program execution. It automatically manages memory allocation and provides the benefits of both arrays and dynamic sizing.

---

## Concept Visualization

```
Static Array (Fixed Size):
┌────┬────┬────┬────┬────┐
│ 10 │ 20 │ 30 │ 40 │ 50 │  Size: 5 (cannot change)
└────┴────┴────┴────┴────┘

Dynamic Array (Resizable):
Initial:
┌────┬────┬────┐
│ 10 │ 20 │ 30 │  Size: 3, Capacity: 4
└────┴────┴────┘

After adding elements:
┌────┬────┬────┬────┬────┬────┬────┬────┐
│ 10 │ 20 │ 30 │ 40 │ 50 │ 60 │ 70 │ 80 │  Size: 8, Capacity: 8
└────┴────┴────┴────┴────┴────┴────┴────┘
                                   (automatically resized!)
```

---

## Key Concepts

### Size vs Capacity

- **Size**: Number of elements currently stored
- **Capacity**: Total space allocated (can be larger than size)

```
┌────┬────┬────┬────┬────┬────┬────┬────┐
│ 10 │ 20 │ 30 │ 40 │    │    │    │    │
└────┴────┴────┴────┴────┴────┴────┴────┘
 ← Size = 4 →  ← Unused capacity →
 ←────────── Capacity = 8 ─────────────→
```

### Growth Strategy

When capacity is exceeded, the array typically:
1. Allocates new memory (usually 2x current capacity)
2. Copies existing elements to new location
3. Frees old memory
4. Updates pointer to new location

```
Step 1: Array Full
┌────┬────┬────┬────┐
│ 10 │ 20 │ 30 │ 40 │  Capacity: 4, Size: 4
└────┴────┴────┴────┘

Step 2: Allocate Larger Array
┌────┬────┬────┬────┬────┬────┬────┬────┐
│    │    │    │    │    │    │    │    │  New Capacity: 8
└────┴────┴────┴────┴────┴────┴────┴────┘

Step 3: Copy Elements
┌────┬────┬────┬────┬────┬────┬────┬────┐
│ 10 │ 20 │ 30 │ 40 │    │    │    │    │
└────┴────┴────┴────┴────┴────┴────┴────┘

Step 4: Add New Element
┌────┬────┬────┬────┬────┬────┬────┬────┐
│ 10 │ 20 │ 30 │ 40 │ 50 │    │    │    │  Size: 5
└────┴────┴────┴────┴────┴────┴────┴────┘
```

---

## Implementation Examples

### C++ std::vector

```cpp
#include <vector>

// Declaration
std::vector<int> vec;

// With initial size
std::vector<int> vec(5);        // 5 elements, default value 0

// With initial values
std::vector<int> vec = {10, 20, 30, 40, 50};

// Adding elements
vec.push_back(60);              // Add to end
vec.insert(vec.begin(), 5);     // Insert at beginning

// Accessing elements
cout << vec[0];                 // Access by index
cout << vec.at(1);              // Bounds-checked access
cout << vec.front();            // First element
cout << vec.back();             // Last element

// Size and capacity
cout << vec.size();             // Number of elements
cout << vec.capacity();         // Allocated capacity
vec.reserve(100);               // Reserve capacity
vec.shrink_to_fit();            // Release unused capacity

// Removing elements
vec.pop_back();                 // Remove last element
vec.erase(vec.begin() + 2);     // Remove element at index 2
vec.clear();                    // Remove all elements

// Checking if empty
if (vec.empty()) {
    cout << "Vector is empty";
}

// Iterating
for (int i = 0; i < vec.size(); i++) {
    cout << vec[i] << " ";
}

// Range-based loop
for (int element : vec) {
    cout << element << " ";
}
```


---


## Time Complexity

### Operations Comparison

| Operation | Static Array | Dynamic Array (Amortized) |
|-----------|-------------|---------------------------|
| Access by index | O(1) | O(1) |
| Search | O(n) | O(n) |
| Insert at end | N/A | O(1)* |
| Insert at beginning | N/A | O(n) |
| Insert at middle | N/A | O(n) |
| Delete at end | N/A | O(1) |
| Delete at beginning | N/A | O(n) |
| Delete at middle | N/A | O(n) |

*Amortized O(1) - occasionally O(n) when resizing

---

## Common Operations

### Initialization

```cpp
std::vector<int> vec;

// Check if empty
if (vec.empty()) {
    cout << "Empty vector";
}

// Add elements
vec.push_back(10);
vec.push_back(20);
vec.push_back(30);

// Get size
cout << "Size: " << vec.size();        // 3
cout << "Capacity: " << vec.capacity(); // >= 3
```

### Insertion

```cpp
std::vector<int> vec = {10, 20, 30, 40};

// Insert at beginning
vec.insert(vec.begin(), 5);
// Result: {5, 10, 20, 30, 40}

// Insert at middle
vec.insert(vec.begin() + 2, 15);
// Result: {5, 10, 15, 20, 30, 40}

// Insert multiple elements
vec.insert(vec.end(), {50, 60, 70});
// Result: {5, 10, 15, 20, 30, 40, 50, 60, 70}
```

### Deletion

```cpp
std::vector<int> vec = {10, 20, 30, 40, 50};

// Remove last element
vec.pop_back();
// Result: {10, 20, 30, 40}

// Remove at specific position
vec.erase(vec.begin() + 1);
// Result: {10, 30, 40}

// Remove range
vec.erase(vec.begin(), vec.begin() + 2);
// Result: {40}

// Clear all
vec.clear();
// Result: {}
```

---

## 2D Dynamic Arrays

### C++ Vector of Vectors

```cpp
// Declaration
std::vector<std::vector<int>> matrix;

// Initialize with size
int rows = 3, cols = 4;
std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols, 0));

// Initialize with values
std::vector<std::vector<int>> matrix = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// Access elements
cout << matrix[1][2];  // Output: 7

// Add row
matrix.push_back({13, 14, 15, 16});

// Traverse
for (int i = 0; i < matrix.size(); i++) {
    for (int j = 0; j < matrix[i].size(); j++) {
        cout << matrix[i][j] << " ";
    }
    cout << endl;
}
```

---

## Advantages

✅ **Dynamic sizing** - Grows and shrinks as needed
✅ **Fast random access** - O(1) like regular arrays
✅ **Automatic memory management** - No manual allocation/deallocation
✅ **Cache-friendly** - Contiguous memory storage
✅ **Convenient** - Rich API with many built-in operations
✅ **Type-safe** - Compile-time type checking

---

## Disadvantages

❌ **Reallocation cost** - Occasional O(n) for insertions when resizing
❌ **Memory overhead** - Unused capacity consumes memory
❌ **Insertion/deletion in middle** - O(n) operations
❌ **Memory fragmentation** - Repeated resizing can fragment heap
❌ **Pointer invalidation** - Reallocation invalidates pointers/iterators

---

## Best Practices

1. **Reserve capacity** when size is known in advance
2. **Use emplace_back** for complex objects
3. **Pass by reference** to avoid unnecessary copies
4. **Use at()** for bounds-checked access in debug code
5. **Prefer push_back** for adding at end
6. **Use shrink_to_fit** when finished growing
7. **Check empty()** before accessing elements
8. **Use const references** when reading only


---

## Summary

Dynamic arrays combine the benefits of arrays (fast random access, cache-friendly) with dynamic sizing capabilities. They automatically manage memory allocation and provide amortized O(1) insertion at the end. While they have some overhead for resizing and poor performance for front/middle insertions, they are one of the most commonly used data structures due to their versatility and excellent overall performance.