---
DATE: 2025-10-31T10:28:00
DONE: true
---



## What is a Binary Tree?

A binary tree is a hierarchical data structure where each node has at most two children, called the left child and the right child. Think of it like a family tree, but each person can have at most two children.

### Visual Representation

```mermaid
graph TD
    A[Root: 10] --> B[Left Child: 5]
    A --> C[Right Child: 15]
    B --> D[3]
    B --> E[7]
    C --> F[12]
    C --> G[20]
    
    style A fill:#4CAF50,color:#fff
    style B fill:#2196F3,color:#fff
    style C fill:#2196F3,color:#fff
    style D fill:#FF9800,color:#fff
    style E fill:#FF9800,color:#fff
    style F fill:#FF9800,color:#fff
    style G fill:#FF9800,color:#fff
```

---

## Core Concepts

### Key Terminology

- **Root**: The topmost node (where the tree starts)
- **Parent**: A node that has children below it
- **Child**: A node connected below a parent node
- **Leaf**: Nodes at the bottom with no children
- **Height**: The longest path from root to any leaf
- **Level**: The distance from the root (root is at level 0)

### Node Structure

Each node in a binary tree typically contains:
1. **Data** - The value stored in the node
2. **Left pointer** - Reference to the left child
3. **Right pointer** - Reference to the right child

```mermaid
graph LR
    A[Node Structure] --> B[Data/Value]
    A --> C[Left Child Pointer]
    A --> D[Right Child Pointer]
    
    style A fill:#9C27B0,color:#fff
    style B fill:#E91E63,color:#fff
    style C fill:#E91E63,color:#fff
    style D fill:#E91E63,color:#fff
```

---

## Types of Binary Trees

### 1. Full Binary Tree

A binary tree where each internal node has zero or two children. No node has just one child.

```mermaid
graph TD
    A[1] --> B[2]
    A --> C[3]
    B --> D[4]
    B --> E[5]
    C --> F[6]
    C --> G[7]
    
    style A fill:#4CAF50,color:#fff
    style B fill:#4CAF50,color:#fff
    style C fill:#4CAF50,color:#fff
```

**Characteristics:**
- Every node has 0 or 2 children (never just 1)
- Efficient for certain algorithms
- Clear hierarchical structure

---

### 2. Perfect Binary Tree

A special binary tree where all leaf nodes are at the same level, and each internal node has two children. This is the most "complete" and balanced form.

```mermaid
graph TD
    A[1] --> B[2]
    A --> C[3]
    B --> D[4]
    B --> E[5]
    C --> F[6]
    C --> G[7]
    
    style A fill:#9C27B0,color:#fff
    style B fill:#9C27B0,color:#fff
    style C fill:#9C27B0,color:#fff
    style D fill:#E91E63,color:#fff
    style E fill:#E91E63,color:#fff
    style F fill:#E91E63,color:#fff
    style G fill:#E91E63,color:#fff
```

**Characteristics:**
- All leaf nodes are at the same level
- Maximum number of nodes for a given height
- Highly efficient for operations

---

### 3. Complete Binary Tree

A binary tree where all levels are completely filled except possibly the lowest level, which must have nodes as far left as possible.

```mermaid
graph TD
    A[1] --> B[2]
    A --> C[3]
    B --> D[4]
    B --> E[5]
    C --> F[6]
    
    style A fill:#FF5722,color:#fff
    style B fill:#FF5722,color:#fff
    style C fill:#FF5722,color:#fff
    style D fill:#FF9800,color:#fff
    style E fill:#FF9800,color:#fff
    style F fill:#FF9800,color:#fff
```

**Characteristics:**
- Filled from left to right
- Used in heap implementations
- Efficient for array storage

---

### 4. Binary Search Tree (BST)

A binary tree where for every node, all nodes in its left subtree have values less than the node's value, and all nodes in its right subtree have values greater than the node's value.

```mermaid
graph TD
    A[8] --> B[3]
    A --> C[10]
    B --> D[1]
    B --> E[6]
    C --> F[14]
    E --> G[4]
    E --> H[7]
    
    style A fill:#2196F3,color:#fff
    style B fill:#03A9F4,color:#fff
    style C fill:#03A9F4,color:#fff
```

**Key Rule:** Left < Parent < Right

**Characteristics:**
- Enables fast search, insert, and delete operations
- Left subtree values are always smaller
- Right subtree values are always larger
- Efficient for searching and sorting

---

### 5. Balanced Binary Tree

A tree where the left and right subtrees of every node differ in height by no more than 1.

```mermaid
graph TD
    A[10] --> B[5]
    A --> C[15]
    B --> D[3]
    B --> E[7]
    C --> F[20]
    
    style A fill:#4CAF50,color:#fff
```

**Characteristics:**
- Height difference ≤ 1 for all nodes
- Maintains O(log N) time complexity for operations
- Examples: AVL trees, Red-Black trees

---

### 6. Degenerate (Skewed) Tree

A tree where each internal node has a single child, either left or right. This is essentially a linked list.

```mermaid
graph TD
    A[1] --> B[2]
    B --> C[3]
    C --> D[4]
    D --> E[5]
    
    style A fill:#F44336,color:#fff
    style B fill:#F44336,color:#fff
    style C fill:#F44336,color:#fff
    style D fill:#F44336,color:#fff
    style E fill:#F44336,color:#fff
```

**Characteristics:**
- Behaves like a linked list with O(n) search time
- Inefficient for most operations
- Results from unbalanced insertions

---

## Real-World Applications

### 1. File Systems
Binary trees organize directories and files hierarchically, similar to how folders contain subfolders.

### 2. Database Indexing
Binary search trees enable efficient data storage and retrieval in databases.

### 3. Expression Evaluation
Compilers use binary trees to parse and evaluate mathematical expressions.

```mermaid
graph TD
    A[Add] --> B[Mutiply]
    A --> C[5]
    B --> D[3]
    B --> E[4]
    
    style A fill:#673AB7,color:#fff
```
*Expression: (3 × 4) + 5 = 17*

### 4. Decision Trees
Used in machine learning for classification and prediction tasks.

### 5. Huffman Coding
Binary trees compress data efficiently by assigning shorter codes to more frequent characters.

### 6. Game AI
Representing game states and possible moves in games like chess.

---

## Key Properties

### Height and Nodes
- A binary tree can have a maximum of 2^(h+1) - 1 nodes at level h (if root is level 0)
- Maximum nodes at any level l = 2^l
- Minimum height for n nodes = log₂(n)

### Traversal Methods

Binary trees can be traversed in different orders:

1. **In-order** (Left → Root → Right)
   - For BST, gives sorted order
   
2. **Pre-order** (Root → Left → Right)
   - Used to create a copy of the tree
   
3. **Post-order** (Left → Right → Root)
   - Used to delete the tree

4. **Level-order** (Level by level, left to right)
   - Breadth-first traversal

```mermaid
graph TD
    A[Traversal Types] --> B[In-order]
    A --> C[Pre-order]
    A --> D[Post-order]
    A --> E[Level-order]
    
    B --> B1[Left-Root-Right]
    C --> C1[Root-Left-Right]
    D --> D1[Left-Right-Root]
    E --> E1[Level by Level]
    
    style A fill:#607D8B,color:#fff
```

---

## Summary

Binary data structures are fundamental building blocks in computer science that provide:

✅ **Hierarchical organization** of data  
✅ **Efficient searching** (especially BST)  
✅ **Fast insertion and deletion** (when balanced)  
✅ **Natural representation** of hierarchical relationships  
✅ **Foundation for advanced structures** (heaps, tries, etc.)

### Quick Reference Table

| Type | Max Children | Special Property | Time Complexity |
|------|--------------|-----------------|-----------------|
| Full Binary | 0 or 2 | No single child nodes | - |
| Perfect Binary | Exactly 2 | All leaves at same level | O(log n) |
| Complete Binary | 0-2 | Filled left to right | O(log n) |
| BST | 0-2 | Left < Root < Right | O(log n) avg |
| Balanced | 0-2 | Height diff ≤ 1 | O(log n) |
| Degenerate | 1 | Like linked list | O(n) |


---

