---
DATE: 2025-11-01T23:29:00
DONE: true
---

## Simple Definition

A **Queue** is a linear data structure that follows the **FIFO (First In, First Out)** principle. *Think of it like a line of people waiting at a ticket counter - the person who arrives first gets served first, and new people join at the back of the line.

## Real-World Analogy

Imagine you're waiting in line at a coffee shop:
- The first person in line gets their coffee first
- New customers join at the back of the line
- You can't cut in the middle
- You can't serve people from the middle

This is exactly how a Queue works in programming!

## Key Characteristics

### FIFO Principle
- **First In, First Out**: The element that goes in first comes out first
- Elements are added at one end (rear/back)
- Elements are removed from the other end (front)

### Basic Operations

1. **Enqueue (Add)**
   - Adds an element to the rear/back of the queue
   - Example: A new customer joins the line

2. **Dequeue (Remove)**
   - Removes an element from the front of the queue
   - Example: The first customer gets served and leaves

3. **Peek/Front**
   - Views the front element without removing it
   - Example: Checking who's next in line

4. **isEmpty**
   - Checks if the queue is empty
   - Returns true if no elements exist

5. **Size**
   - Returns the number of elements in the queue

## Visual Representation

```
FRONT                                    REAR
  ↓                                        ↓
[First] ← [Second] ← [Third] ← [Fourth] ← [Last]
  ↑                                        ↑
Dequeue                                 Enqueue
(Remove)                                  (Add)
```

## Example Walkthrough

Let's see how a queue works step by step:

```
Initial: Queue is empty []

1. Enqueue(5)  → [5]
2. Enqueue(10) → [5, 10]
3. Enqueue(15) → [5, 10, 15]
4. Dequeue()   → Returns 5, Queue becomes [10, 15]
5. Enqueue(20) → [10, 15, 20]
6. Dequeue()   → Returns 10, Queue becomes [15, 20]
7. Peek()      → Returns 15 (doesn't remove it)
```

## Common Use Cases

### 1. Task Scheduling
- Operating systems use queues to manage processes
- Print job management

### 2. Breadth-First Search (BFS)
- Graph and tree traversal algorithms
- Finding shortest paths

### 3. Asynchronous Processing
- Message queues (like RabbitMQ, Kafka)
- Handling API requests

### 4. Call Centers
- Managing incoming calls in order

### 5. Real-Time Systems
- Buffering data streams
- Handling events in order

## Types of Queues

### 1. Simple Queue
- Basic FIFO queue
- Standard operations only

### 2. Circular Queue
- Last position connects back to first
- Efficient use of space
- Avoids wasted space

### 3. Priority Queue
- Elements have priorities
- Higher priority elements dequeue first
- Not strictly FIFO

### 4. Double-Ended Queue (Deque)
- Add/remove from both ends
- More flexible than standard queue

## Implementation Approaches

### Using Array
**Advantages:**
- Simple to implement
- Direct access to elements

**Disadvantages:**
- Fixed size (unless dynamic)
- Dequeue operation is expensive (O(n))
- Wasted space in simple implementation

### Using Linked List
**Advantages:**
- Dynamic size
- Efficient enqueue and dequeue (O(1))
- No wasted space

**Disadvantages:**
- Extra memory for pointers
- No direct access to middle elements

## Time Complexity

| Operation | Time Complexity |
|-----------|----------------|
| Enqueue   | O(1)          |
| Dequeue   | O(1)          |
| Peek      | O(1)          |
| isEmpty   | O(1)          |
| Size      | O(1)          |

## Code Example (Python)

```python
class Queue:
    def __init__(self):
        self.items = []
    
    def enqueue(self, item):
        """Add item to rear of queue"""
        self.items.append(item)
    
    def dequeue(self):
        """Remove and return front item"""
        if not self.is_empty():
            return self.items.pop(0)
        return None
    
    def peek(self):
        """View front item without removing"""
        if not self.is_empty():
            return self.items[0]
        return None
    
    def is_empty(self):
        """Check if queue is empty"""
        return len(self.items) == 0
    
    def size(self):
        """Return number of items"""
        return len(self.items)

# Usage
queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
print(queue.dequeue())  # Output: 1
print(queue.peek())     # Output: 2
```

## Queue vs Stack

| Queue | Stack |
|-------|-------|
| FIFO (First In, First Out) | LIFO (Last In, First Out) |
| Add at rear, remove from front | Add and remove from same end (top) |
| Like a line of people | Like a stack of plates |
| Used in BFS | Used in DFS |

## When to Use Queue

Use a Queue when:
- ✅ Order matters (process items in arrival order)
- ✅ You need fair scheduling (first come, first served)
- ✅ You're implementing BFS algorithm
- ✅ You need to buffer requests or data
- ✅ You're managing asynchronous tasks

Don't use Queue when:
- ❌ You need random access to elements
- ❌ Most recent items should be processed first (use Stack)
- ❌ Priority matters more than order (use Priority Queue)

## Key Points to Remember

1. **FIFO**: First element added is first to be removed
2. **Two ends**: Front (for removal) and Rear (for addition)
3. **O(1) operations**: All basic operations are constant time with proper implementation
4. **Linear structure**: Elements arranged in sequence
5. **Dynamic or fixed**: Can be implemented with either approach

## Common Interview Questions

1. Implement a queue using two stacks
2. Reverse a queue
3. Generate binary numbers from 1 to n using a queue
4. Implement a circular queue
5. Check if a queue can be sorted using another queue

---
