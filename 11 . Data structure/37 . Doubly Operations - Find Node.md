---
DATE: 2025-11-03T23:27:00
DONE: true
---




```cpp

#include <iostream>
using namespace std;

// Create a node
class Node
{
public:
    int value;
    Node* next;
    Node* prev;
};

void InsertAtBeginning(Node*& head, int value) {


    /*
        1-Create a new node with the desired value.
        2-Set the next pointer of the new node to the current head of the list.
        3-Set the previous pointer of the current head to the new node.
        4-Set the new node as the new head of the list.
    */

    Node* newNode = new Node();
    newNode->value = value;
    newNode->next = head;
    newNode->prev = NULL;

    if (head != NULL) {
        head->prev = newNode;
    }
    head = newNode;
}

Node* Find(Node* head, int Value)
{

    while (head != NULL) {

        if (head->value == Value)
            return head;


        head = head->next;
    }

    return NULL;


}


void PrintNodeDetails(Node* head)
{

    if (head->prev != NULL)
        cout << head->prev->value;
    else
        cout << "NULL";

    cout << " <--> " << head->value << " <--> ";

    if (head->next != NULL)
        cout << head->next->value << "\n";
    else
        cout << "NULL";

}

// Print the linked list
void PrintListDetails(Node* head)

{
    cout << "\n\n";
    while (head != NULL) {
        PrintNodeDetails(head);
        head = head->next;
    }
}


// Print the linked list
void PrintList(Node* head)

{
    cout << "NULL <--> ";
    while (head != NULL) {
        cout << head->value << " <--> ";
        head = head->next;
    }
    cout << "NULL";

}

int main()
{
    Node* head = NULL;

    InsertAtBeginning(head, 5);
    InsertAtBeginning(head, 4);
    InsertAtBeginning(head, 3);
    InsertAtBeginning(head, 2);
    InsertAtBeginning(head, 1);

    cout << "\nLinked List Contenet:\n";
    PrintList(head);


    Node* N1 = Find(head, 2);

    if (N1 != NULL)
        cout << "\n\n Node Found :-)\n";
    else
        cout << "\n\n Node Is not found :-(\n";


    system("pause>0");

}
```


# Understanding the Find Node Operation in Doubly Linked Lists

## What is the Find Operation?

The **Find** operation searches through a doubly linked list to locate a node that contains a specific value. Think of it like looking for a specific book on a shelf - you start at one end and check each book until you find the one you're looking for (or reach the end).

## Visual Representation

### The Doubly Linked List Structure

```
NULL ‚Üê [1] ‚Üî [2] ‚Üî [3] ‚Üî [4] ‚Üî [5] ‚Üí NULL
        ‚Üë
      head
```

Each node has:

- A **value** (the number stored)
- A **next** pointer (arrow pointing right ‚Üí)
- A **prev** pointer (arrow pointing left ‚Üê)

### How Find Works - Step by Step

Let's say we want to find the node with value **2**:

**Step 1:** Start at the head (first node)

```
       üëâ Looking here
NULL ‚Üê [1] ‚Üî [2] ‚Üî [3] ‚Üî [4] ‚Üî [5] ‚Üí NULL
        ‚Üë
      head
```

- Is 1 == 2? No, move to next node

**Step 2:** Move to the next node

```
            üëâ Looking here
NULL ‚Üê [1] ‚Üî [2] ‚Üî [3] ‚Üî [4] ‚Üî [5] ‚Üí NULL
```

- Is 2 == 2? **Yes! Found it!** ‚úì
- Return this node

### If the Value Doesn't Exist

Let's search for value **10** (which doesn't exist):

```
       üëâ Check 1? No
            üëâ Check 2? No
                 üëâ Check 3? No
                      üëâ Check 4? No
                           üëâ Check 5? No
                                    üëâ NULL reached!

NULL ‚Üê [1] ‚Üî [2] ‚Üî [3] ‚Üî [4] ‚Üî [5] ‚Üí NULL
```

When we reach NULL (end of list), return NULL = "Not Found"

## The Algorithm in Plain English

```
Function Find(head, targetValue):
    1. Start at the head of the list
    2. While we haven't reached the end (NULL):
        a. Check if current node's value equals targetValue
        b. If yes: Return this node (Success!)
        c. If no: Move to the next node
    3. If we've checked all nodes: Return NULL (Not Found)
```

## The Code Explained

```cpp
Node* Find(Node* head, int Value)
{
    // Keep checking until we reach the end (NULL)
    while (head != NULL) {
        
        // Found it! Return the node
        if (head->value == Value)
            return head;
        
        // Not found yet, move to next node
        head = head->next;
    }
    
    // Reached the end without finding it
    return NULL;
}
```

## Time Complexity

- **Best Case:** O(1) - Value is at the first node
- **Average Case:** O(n/2) - Value is somewhere in the middle
- **Worst Case:** O(n) - Value is at the last node or doesn't exist

Where **n** is the number of nodes in the list.

## Practical Example from the Code

The main function creates this list:

```
NULL ‚Üê [1] ‚Üî [2] ‚Üî [3] ‚Üî [4] ‚Üî [5] ‚Üí NULL
```

Then searches for value **2**:

```cpp
Node* N1 = Find(head, 2);  // Returns pointer to node with value 2

if (N1 != NULL)
    cout << "Node Found :-)";     // This will print!
else
    cout << "Node not found :-(";
```

## Key Points to Remember

‚úÖ **Linear Search:** We check each node one by one from start to end

‚úÖ **Returns a Pointer:** If found, returns the memory address of the node (not just the value)

‚úÖ **Returns NULL:** If not found, returns NULL (used to check if search was successful)

‚úÖ **Non-Destructive:** The Find operation doesn't modify the list - it only reads

‚úÖ **Works for any list:** Empty list, single node, or many nodes

## Why Return a Pointer?

Returning the actual node pointer is useful because you can:

- Access the node's value: `N1->value`
- Navigate to adjacent nodes: `N1->next` or `N1->prev`
- Modify the node: `N1->value = 10`
- Use it for other operations like deletion or insertion

This makes the Find operation a building block for many other list operations!