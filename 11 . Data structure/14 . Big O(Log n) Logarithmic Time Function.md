---
DATE: 2025-10-30T11:49:00
DONE: true
---



**O(log n)** describes algorithms whose execution time grows **logarithmically** with input size. This is one of the most efficient time complexities after O(1).

> **Key Insight**: As input doubles, operations increase by only +1

---

## ğŸ”¢ Understanding Logarithms

### What is a Logarithm?

A logarithm answers the question: **"How many times must we divide n by 2 to get 1?"**

```
logâ‚‚(8) = 3     â†’ 8 Ã· 2 Ã· 2 Ã· 2 = 1
logâ‚‚(16) = 4    â†’ 16 Ã· 2 Ã· 2 Ã· 2 Ã· 2 = 1
logâ‚‚(32) = 5    â†’ 32 Ã· 2 Ã· 2 Ã· 2 Ã· 2 Ã· 2 = 1
```

### Visual Representation

```mermaid
graph LR
    A[16] -->|Ã·2| B[8]
    B -->|Ã·2| C[4]
    C -->|Ã·2| D[2]
    D -->|Ã·2| E[1]
    
    style A fill:#ff6b6b
    style E fill:#51cf66
```

**Steps needed**: 4 operations for n=16

---

## ğŸ“ˆ Growth Rate Comparison

| Input Size (n) | O(1) | O(log n) | O(n) | O(nÂ²) |
|----------------|------|----------|------|-------|
| 1              | 1    | 0        | 1    | 1     |
| 10             | 1    | 3        | 10   | 100   |
| 100            | 1    | 6        | 100  | 10,000|
| 1,000          | 1    | 10       | 1,000| 1M    |
| 1,000,000      | 1    | 20       | 1M   | 1T    |

### Growth Visualization

```mermaid
graph TD
    subgraph "Operations vs Input Size"
    A["n=1<br/>ops=0"] --> B["n=2<br/>ops=1"]
    B --> C["n=4<br/>ops=2"]
    C --> D["n=8<br/>ops=3"]
    D --> E["n=16<br/>ops=4"]
    E --> F["n=32<br/>ops=5"]
    end
    
    style A fill:#e3f2fd
    style F fill:#1976d2,color:#fff
```

**Notice**: Input doubles, but operations only increase by 1!

---

## ğŸ’» Code Example Analysis

### Simple Division Loop

```cpp
void fun1(short n)
{
    short x = n;
    while (x > 0)
    {
        x = x / 2;
        cout << x << endl;
    }
}
```

### Complexity Calculation

```mermaid
flowchart TD
    Start([Start: x = n]) --> Check{x > 0?}
    Check -->|Yes| Divide[x = x / 2]
    Divide --> Print[Print x]
    Print --> Check
    Check -->|No| End([End])
    
    style Start fill:#51cf66
    style End fill:#ff6b6b
    style Check fill:#ffd43b
```

**Breakdown**:
- **Outside loop**: 1 step (initialization)
- **Inside loop**: 7 steps per iteration
- **Number of iterations**: logâ‚‚(n)

**Big O Calculation**:
```
Total Steps = 1 + (7 Ã— log n)
            = 1 + 7 log n
            â‰ˆ log n  (drop constants)
            
Therefore: O(log n)
```

---

## ğŸ¯ Real-World Examples

### 1. Binary Search

Searching in a sorted array by repeatedly dividing the search space:

```cpp
int binarySearch(int arr[], int size, int target) {
    int left = 0, right = size - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target)
            return mid;
        else if (arr[mid] < target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return -1;
}
```

**Why O(log n)?** Each comparison eliminates half of the remaining elements.

### 2. Finding Power of 2

```cpp
bool isPowerOfTwo(int n) {
    while (n > 1) {
        if (n % 2 != 0)
            return false;
        n = n / 2;  // Halving each time
    }
    return n == 1;
}
```

### 3. Phone Book Search

Looking up a name in a phone book:
- Start in the middle
- Go to first or second half based on name
- Repeat until found

---

## ğŸ” Step-by-Step Example

### Example: fun1(16)

```
Iteration 1: x = 16/2 = 8    âœ“
Iteration 2: x = 8/2  = 4    âœ“
Iteration 3: x = 4/2  = 2    âœ“
Iteration 4: x = 2/2  = 1    âœ“
Iteration 5: x = 1/2  = 0    â†’ Loop exits

Total iterations: 5 = logâ‚‚(16) + 1
```

### Trace Diagram

```mermaid
stateDiagram-v2
    [*] --> x16: n=16
    x16 --> x8: x/2
    x8 --> x4: x/2
    x4 --> x2: x/2
    x2 --> x1: x/2
    x1 --> x0: x/2
    x0 --> [*]: exit
    
    note right of x16
        Starting point
    end note
    
    note right of x0
        Loop condition fails
    end note
```

---

## âš¡ Why O(log n) is Efficient

### Comparison with Linear Time

| Algorithm Type | Input: 1M items | Operations |
|---------------|-----------------|------------|
| O(n) - Linear | 1,000,000      | 1,000,000  |
| O(log n) - Log| 1,000,000      | **20**     |

**Efficiency**: Log is **50,000Ã— faster** for large datasets!

---

## ğŸ“ Key Characteristics

### âœ… Properties
- **Dividing work**: Problem size reduces by fraction each step
- **Very efficient**: Second-best after O(1)
- **Common in**: Binary search, tree operations, divide-and-conquer

### ğŸ”‘ Recognition Patterns

You likely have O(log n) when:
1. âœ“ Input is divided in half repeatedly
2. âœ“ Using binary search approach
3. âœ“ Traversing balanced binary trees
4. âœ“ Loop variable multiplies/divides by constant

---

## ğŸ“ Quick Reference

### Formula Summary
```
Operations = logâ‚‚(n)

Where:
- n = input size
- logâ‚‚ = logarithm base 2
- Each iteration cuts problem in half
```

### Complexity Hierarchy
```
Fastest âš¡ â†’ Slowest ğŸŒ

O(1) < O(log n) < O(n) < O(n log n) < O(nÂ²) < O(2â¿)
     â† You are here
```

---

## ğŸ’¡ Tips for Identification

1. **Look for halving**: Variable divided by 2 (or multiplied/divided by constant)
2. **Check loop condition**: Does it eliminate half the problem?
3. **Binary patterns**: Anything "binary" usually hints at log complexity
4. **Tree height**: Balanced tree operations are often O(log n)


---

## ğŸ“š Summary

> **O(log n)** means efficiency scales beautifully with size. Doubling input adds just one operation. Perfect for searching, tree operations, and divide-and-conquer algorithms.

**Remember**: When you see repeated division or halving, think logarithmic!

---
